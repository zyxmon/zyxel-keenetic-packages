diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/aaa.c ppp-2.4.4/pppd/plugins/pppol2tp/aaa.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/aaa.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/aaa.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,343 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Authorization, Accounting, and Access control
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <string.h>
-#include <errno.h>
-#include "l2tp.h"
-
-extern void bufferDump (char *, int);
-
-void mk_challenge (unsigned char *c, int length)
-{
-    get_entropy(c, length);
-
-    /* int x;
-    int *s = (int *) c;
-    for (x = 0; x < length / sizeof (int); x++)
-        s[x] = rand (); */
-}
-
-int get_secret (char *us, char *them, unsigned char *secret, int size)
-{
-    FILE *f;
-    char buf[STRLEN];
-    char *u, *t, *s;
-    int num = 0;
-    f = fopen (AUTH_FILE, "r");
-    if (!f)
-    {
-        l2tp_log (LOG_WARNING, "%s : Unable to open '%s' for authentication\n",
-             __FUNCTION__, AUTH_FILE);
-        return 0;
-    }
-    while (!feof (f))
-    {
-        num++;
-        fgets (buf, sizeof (buf), f);
-        if (feof (f))
-            break;
-        /* Strip comments */
-        for (t = buf; *t; t++)
-            *t = ((*t == '#') || (*t == ';')) ? 0 : *t;
-        /* Strip trailing whitespace */
-        for (t = buf + strlen (buf) - 1; (t >= buf) && (*t < 33); t--)
-            *t = 0;
-        if (!strlen (buf))
-            continue;           /* Empty line */
-        u = buf;
-        while (*u && (*u < 33))
-            u++;
-        /* us */
-        if (!*u)
-        {
-            l2tp_log (LOG_WARNING,
-                 "%s: Invalid authentication info (no us), line %d\n",
-                 __FUNCTION__, num);
-            continue;
-        }
-        t = u;
-        while (*t > 32)
-            t++;
-        *(t++) = 0;
-        while (*t && (*t < 33))
-            t++;
-        /* them */
-        if (!*t)
-        {
-            l2tp_log (LOG_WARNING,
-                 "%s: Invalid authentication info (nothem), line %d\n",
-                 __FUNCTION__, num);
-            continue;
-        }
-        s = t;
-        while (*s > 33)
-            s++;
-        *(s++) = 0;
-        while (*s && (*s < 33))
-            s++;
-        if (!*s)
-        {
-            l2tp_log (LOG_WARNING,
-                 "%s: Invalid authentication info (no secret), line %d\n",
-                 __FUNCTION__, num);
-            continue;
-        }
-        if ((!strcasecmp (u, us) || !strcasecmp (u, "*")) &&
-            (!strcasecmp (t, them) || !strcasecmp (t, "*")))
-        {
-#ifdef DEBUG_AUTH
-            l2tp_log (LOG_DEBUG,
-                 "%s: we are '%s', they are '%s', secret is '%s'\n",
-                 __FUNCTION__, u, t, s);
-#endif
-            strncpy ((char *)secret, s, size);
-            fclose(f);
-            return -1;
-        }
-    }
-    fclose(f);
-    return 0;
-}
-
-int handle_challenge (struct tunnel *t, struct challenge *chal)
-{
-    char *us;
-    char *them;
-    if (!t->lac)
-    {
-        l2tp_log (LOG_DEBUG, "%s: No LAC to handle challenge!\n",
-             __FUNCTION__);
-        return -1;
-    }
-#ifdef DEBUG_AUTH
-    l2tp_log (LOG_DEBUG, "%s: making response for tunnel: %d\n", __FUNCTION__,
-         t->ourtid);
-#endif
-    if (t->lac->hostname[0])
-        us = t->lac->hostname;
-    else
-        us = hostname;
-    if (t->lac->peername[0])
-        them = t->lac->peername;
-    else
-        them = t->hostname;
-
-    if (!get_secret (us, them, chal->secret, sizeof (chal->secret)))
-    {
-        l2tp_log (LOG_DEBUG, "%s: no secret found for us='%s' and them='%s'\n",
-             __FUNCTION__, us, them);
-        return -1;
-    }
-
-#if DEBUG_AUTH
-    l2tp_log (LOG_DEBUG, "*%s: Here comes the chal->ss:\n", __FUNCTION__);
-    bufferDump (&chal->ss, 1);
-
-    l2tp_log (LOG_DEBUG, "%s: Here comes the secret\n", __FUNCTION__);
-    bufferDump (chal->secret, strlen (chal->secret));
-
-    l2tp_log (LOG_DEBUG, "%s: Here comes the challenge\n", __FUNCTION__);
-    bufferDump (chal->challenge, chal->chal_len);
-#endif
-
-    memset (chal->response, 0, MD_SIG_SIZE);
-    MD5Init (&chal->md5);
-    MD5Update (&chal->md5, &chal->ss, 1);
-    MD5Update (&chal->md5, chal->secret, strlen ((char *)chal->secret));
-    MD5Update (&chal->md5, chal->challenge, chal->chal_len);
-    MD5Final (chal->response, &chal->md5);
-#ifdef DEBUG_AUTH
-    l2tp_log (LOG_DEBUG, "response is %X%X%X%X to '%s' and %X%X%X%X, %d\n",
-         *((int *) &chal->response[0]),
-         *((int *) &chal->response[4]),
-         *((int *) &chal->response[8]),
-         *((int *) &chal->response[12]),
-         chal->secret,
-         *((int *) &chal->challenge[0]),
-         *((int *) &chal->challenge[4]),
-         *((int *) &chal->challenge[8]),
-         *((int *) &chal->challenge[12]), chal->ss);
-#endif
-    chal->state = STATE_CHALLENGED;
-    return 0;
-}
-
-#ifdef DEBUG_HIDDEN
-void print_md5 (void *md5)
-{
-    int *i = (int *) md5;
-    l2tp_log (LOG_DEBUG, "%X%X%X%X\n", i[0], i[1], i[2], i[3], i[4]);
-}
-
-inline void print_challenge (struct challenge *chal)
-{
-    l2tp_log (LOG_DEBUG, "vector: ");
-    print_md5 (chal->vector);
-    l2tp_log (LOG_DEBUG, "secret: %s\n", chal->secret);
-}
-#endif
-void encrypt_avp (struct buffer *buf, _u16 len, struct tunnel *t)
-{
-    /* Encrypts an AVP of len, at data.  We assume there
-       are two "spare bytes" before the data pointer,l but otherwise
-       this is just a normal AVP that is about to be returned from
-       an avpsend routine */
-    struct avp_hdr *new_hdr =
-        (struct avp_hdr *) (buf->start + buf->len - len);
-    struct avp_hdr *old_hdr =
-        (struct avp_hdr *) (buf->start + buf->len - len + 2);
-    _u16 length, flags, attr;   /* New length, old flags */
-    unsigned char *ptr, *end;
-    int cnt;
-    unsigned char digest[MD_SIG_SIZE];
-    unsigned char *previous_segment;
-
-    /* FIXME: Should I pad more randomly? Right now I pad to nearest 16 bytes */
-    length =
-        ((len - sizeof (struct avp_hdr) + 1) / 16 + 1) * 16 +
-        sizeof (struct avp_hdr);
-    flags = htons (old_hdr->length) & 0xF000;
-    new_hdr->length = htons (length | flags | HBIT);
-    new_hdr->vendorid = old_hdr->vendorid;
-    new_hdr->attr = attr = old_hdr->attr;
-    /* This is really the length field of the hidden sub-format */
-    old_hdr->attr = htons (len - sizeof (struct avp_hdr));
-    /* Okay, now we've rewritten the header, as it should be.  Let's start
-       encrypting the actual data now */
-    buf->len -= len;
-    buf->len += length;
-    /* Back to the beginning of real data, including the original length AVP */
-
-    MD5Init (&t->chal_them.md5);
-    MD5Update (&t->chal_them.md5, (void *) &attr, 2);
-    MD5Update (&t->chal_them.md5, t->chal_them.secret,
-               strlen ((char *)t->chal_them.secret));
-    MD5Update (&t->chal_them.md5, t->chal_them.vector, VECTOR_SIZE);
-    MD5Final (digest, &t->chal_them.md5);
-
-    /* Though not a "MUST" in the spec, our subformat length is always a multiple of 16 */
-    ptr = ((unsigned char *) new_hdr) + sizeof (struct avp_hdr);
-    end = ((unsigned char *) new_hdr) + length;
-    previous_segment = ptr;
-    while (ptr < end)
-    {
-#if DEBUG_HIDDEN
-        l2tp_log (LOG_DEBUG, "%s: The digest to be XOR'ed\n", __FUNCTION__);
-        bufferDump (digest, MD_SIG_SIZE);
-        l2tp_log (LOG_DEBUG, "%s: The plaintext to be XOR'ed\n", __FUNCTION__);
-        bufferDump (ptr, MD_SIG_SIZE);
-#endif
-        for (cnt = 0; cnt < MD_SIG_SIZE; cnt++, ptr++)
-        {
-            *ptr = *ptr ^ digest[cnt];
-        }
-#if DEBUG_HIDDEN
-        l2tp_log (LOG_DEBUG, "%s: The result of XOR\n", __FUNCTION__);
-        bufferDump (previous_segment, MD_SIG_SIZE);
-#endif
-        if (ptr < end)
-        {
-            MD5Init (&t->chal_them.md5);
-            MD5Update (&t->chal_them.md5, t->chal_them.secret,
-                       strlen ((char *)t->chal_them.secret));
-            MD5Update (&t->chal_them.md5, previous_segment, MD_SIG_SIZE);
-            MD5Final (digest, &t->chal_them.md5);
-        }
-        previous_segment = ptr;
-    }
-}
-
-int decrypt_avp (char *buf, struct tunnel *t)
-{
-    /* Decrypts a hidden AVP pointed to by buf.  The
-       new header will be exptected to be two characters
-       offset from the old */
-    int cnt = 0;
-    int len, olen, flags;
-    unsigned char digest[MD_SIG_SIZE];
-    char *ptr, *end;
-    _u16 attr;
-    struct avp_hdr *old_hdr = (struct avp_hdr *) buf;
-    struct avp_hdr *new_hdr = (struct avp_hdr *) (buf + 2);
-    int saved_segment_len;      /* maybe less 16; may be used if the cipher is longer than 16 octets */
-    unsigned char saved_segment[MD_SIG_SIZE];
-    ptr = ((char *) old_hdr) + sizeof (struct avp_hdr);
-    olen = old_hdr->length & 0x0FFF;
-    end = buf + olen;
-    if (!t->chal_us.vector)
-    {
-        l2tp_log (LOG_DEBUG,
-             "decrypt_avp: Hidden bit set, but no random vector specified!\n");
-        return -EINVAL;
-    }
-    /* First, let's decrypt all the data.  We're not guaranteed
-       that it will be padded to a 16 byte boundary, so we
-       have to be more careful than when encrypting */
-    attr = ntohs (old_hdr->attr);
-    MD5Init (&t->chal_us.md5);
-    MD5Update (&t->chal_us.md5, (void *) &attr, 2);
-    MD5Update (&t->chal_us.md5, t->chal_us.secret,
-               strlen ((char *)t->chal_us.secret));
-    MD5Update (&t->chal_us.md5, t->chal_us.vector, t->chal_us.vector_len);
-    MD5Final (digest, &t->chal_us.md5);
-#ifdef DEBUG_HIDDEN
-    l2tp_log (LOG_DEBUG, "attribute is %d and challenge is: ", attr);
-    print_challenge (&t->chal_us);
-    l2tp_log (LOG_DEBUG, "md5 is: ");
-    print_md5 (digest);
-#endif
-    while (ptr < end)
-    {
-        if (cnt >= MD_SIG_SIZE)
-        {
-            MD5Init (&t->chal_us.md5);
-            MD5Update (&t->chal_us.md5, t->chal_us.secret,
-                       strlen ((char *)t->chal_us.secret));
-            MD5Update (&t->chal_us.md5, saved_segment, MD_SIG_SIZE);
-            MD5Final (digest, &t->chal_us.md5);
-            cnt = 0;
-        }
-        /* at the beginning of each segment, we save the current segment (16 octets or less) of cipher 
-         * so that the next round of MD5 (if there is a next round) hash could use it 
-         */
-        if (cnt == 0)
-        {
-            saved_segment_len =
-                (end - ptr < MD_SIG_SIZE) ? (end - ptr) : MD_SIG_SIZE;
-            memcpy (saved_segment, ptr, saved_segment_len);
-        }
-        *ptr = *ptr ^ digest[cnt++];
-        ptr++;
-    }
-    /* Hopefully we're all nice and decrypted now.  Let's rewrite the header. 
-       First save the old flags, and get the new stuff */
-    flags = old_hdr->length & 0xF000 & ~HBIT;
-    len = ntohs (new_hdr->attr) + sizeof (struct avp_hdr);
-    if (len > olen - 2)
-    {
-        l2tp_log (LOG_DEBUG,
-             "decrypt_avp: Decrypted length is too long (%d > %d)\n", len,
-             olen - 2);
-        return -EINVAL;
-    }
-    new_hdr->attr = old_hdr->attr;
-    new_hdr->vendorid = old_hdr->vendorid;
-    new_hdr->length = len | flags;
-    return 0;
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/aaa.h ppp-2.4.4/pppd/plugins/pppol2tp/aaa.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/aaa.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/aaa.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,52 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Authorization, Accounting, and Access control
- *
- */
-
-#ifndef _AAA_H
-#define _AAA_H
-#include "md5.h"
-
-#define ADDR_HASH_SIZE 256
-#define MD_SIG_SIZE 16
-#define MAX_VECTOR_SIZE 1024
-#define VECTOR_SIZE 16
-
-#define STATE_NONE 		 0
-#define STATE_CHALLENGED 1
-#define STATE_COMPLETE	 2
-
-struct addr_ent
-{
-    unsigned int addr;
-    struct addr_ent *next;
-};
-
-struct challenge
-{
-    struct MD5Context md5;
-    unsigned char ss;           /* State we're sending in */
-    unsigned char secret[MAXSTRLEN];    /* The shared secret */
-    unsigned char *challenge;       /* The original challenge */
-    unsigned int chal_len;       /* The length of the original challenge */
-    unsigned char response[MD_SIG_SIZE];        /* What we expect as a respsonse */
-    unsigned char reply[MD_SIG_SIZE];   /* What the peer sent */
-    unsigned char *vector;
-    unsigned int vector_len;
-    int state;                  /* What state is challenge in? */
-};
-
-extern void init_addr ();
-extern int handle_challenge (struct tunnel *, struct challenge *);
-extern void mk_challenge (unsigned char *, int);
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/avp.c ppp-2.4.4/pppd/plugins/pppol2tp/avp.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/avp.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/avp.c	2013-01-17 16:41:53.571157041 +0400
@@ -1,1776 +1,370 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Attribute Value Pair handler routines
- */
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <errno.h>
-#include <netinet/in.h>
-#include "l2tp.h"
+#include "common.h"
 
-#define AVP_MAX 39
+int l2tp_avp_parse(PL2TP_STATE pstate, const uint8_t *pdata, uint32_t upktlen, PL2TP_AVP *ppres) {
+	COMMON_POINTER cp;
+	PL2TP_AVP pavp_head, pavp_tail, pavp;
+	uint16_t uhead, ulen, utid, usid;
 
-struct avp avps[] = {
+	*ppres = NULL;
+	pavp_head = NULL;
+	pavp_tail = NULL;
 
-    {0, 1, &message_type_avp, "Message Type"},
-    {1, 1, &result_code_avp, "Result Code"},
-    {2, 1, &protocol_version_avp, "Protocol Version"},
-    {3, 1, &framing_caps_avp, "Framing Capabilities"},
-    {4, 1, &bearer_caps_avp, "Bearer Capabilities"},
-    {5, 0, NULL, "Tie Breaker"},
-    {6, 0, &firmware_rev_avp, "Firmware Revision"},
-    {7, 0, &hostname_avp, "Host Name"},
-    {8, 1, &vendor_avp, "Vendor Name"},
-    {9, 1, &assigned_tunnel_avp, "Assigned Tunnel ID"},
-    {10, 1, &receive_window_size_avp, "Receive Window Size"},
-    {11, 1, &challenge_avp, "Challenge"},
-    {12, 0, NULL, "Q.931 Cause Code"},
-    {13, 1, &chalresp_avp, "Challenge Response"},
-    {14, 1, &assigned_call_avp, "Assigned Call ID"},
-    {15, 1, &call_serno_avp, "Call Serial Number"},
-    {16, 1, NULL, "Minimum BPS"},
-    {17, 1, NULL, "Maximum BPS"},
-    {18, 1, &bearer_type_avp, "Bearer Type"},
-    {19, 1, &frame_type_avp, "Framing Type"},
-    {20, 1, &packet_delay_avp, "Packet Processing Delay"},
-    {21, 1, &dialed_number_avp, "Dialed Number"},
-    {22, 1, &dialing_number_avp, "Dialing Number"},
-    {23, 1, &sub_address_avp, "Sub-Address"},
-    {24, 1, &tx_speed_avp, "Transmit Connect Speed"},
-    {25, 1, &call_physchan_avp, "Physical channel ID"},
-    {26, 0, NULL, "Initial Received LCP Confreq"},
-    {27, 0, NULL, "Last Sent LCP Confreq"},
-    {28, 0, NULL, "Last Received LCP Confreq"},
-    {29, 1, &ignore_avp, "Proxy Authen Type"},
-    {30, 0, &ignore_avp, "Proxy Authen Name"},
-    {31, 0, &ignore_avp, "Proxy Authen Challenge"},
-    {32, 0, &ignore_avp, "Proxy Authen ID"},
-    {33, 1, &ignore_avp, "Proxy Authen Response"},
-    {34, 1, NULL, "Call Errors"},
-    {35, 1, &ignore_avp, "ACCM"},
-    {36, 1, &rand_vector_avp, "Random Vector"},
-    {37, 1, NULL, "Private Group ID"},
-    {38, 0, &rx_speed_avp, "Receive Connect Speed"},
-    {39, 1, &seq_reqd_avp, "Sequencing Required"}
-};
+	if( upktlen < L2TP_HLEN ) return -1;
 
-char *msgtypes[] = {
-    NULL,
-    "Start-Control-Connection-Request",
-    "Start-Control-Connection-Reply",
-    "Start-Control-Connection-Connected",
-    "Stop-Control-Connection-Notification",
-    NULL,
-    "Hello",
-    "Outgoing-Call-Request",
-    "Outgoing-Call-Reply",
-    "Outgoing-Call-Connected",
-    "Incoming-Call-Request",
-    "Incoming-Call-Reply",
-    "Incoming-Call-Connected",
-    NULL,
-    "Call-Disconnect-Notify",
-    "WAN-Error-Notify",
-    "Set-Link-Info"
-};
+	cp.pu8 = (uint8_t *)pdata;
+	uhead = ntohs(*cp.pu16++);
 
-char *stopccn_result_codes[] = {
-    "Reserved",
-    "General request to clear control connection",
-    "General error--Error Code indicates the problem",
-    "Control channel already exists",
-    "Requester is not authorized to establish a control channel",
-    "The protocol version of the requester is not supported--Error Code indicates the highest version supported",
-    "Requester is being shut down",
-    "Finite State Machine error"
-};
+	if( !(uhead & L2TP_TBIT) )  return -2; /* not control message */
+	if( !(uhead & L2TP_LBIT) )  return -3; /* no length bit in control message */
+	if( !(uhead & L2TP_SBIT) )  return -4; /* no Ns/Nr fields in control message */
+	if( (uhead & L2TP_OBIT) )   return -5; /*  offset bit must not be set in control message */
+	if( (uhead & L2TP_PBIT) )   return -6; /*  priority bit must not be set in control message */
+	if( (uhead & 0xF) != L2TP_VERSION ) return -7; /* version must be 2 */
 
-char *cdn_result_codes[] = {
-    "Reserved",
-    "Call disconnected due to loss of carrier",
-    "Call disconnected for the reason indicated in error code",
-    "Call disconnected for administrative reasons",
-    "Call failed due to lack of appropriate facilities being available (temporary condition)",
-    "Call failed due to lack of appropriate facilities being available (permanent condition)",
-    "Invalid destination",
-    "Call failed due to no carrier detected",
-    "Call failed due to lack of a dial tone",
-    "Call was no established within time allotted by LAC",
-    "Call was connected but no appropriate framing was detect"
-};
+	ulen = ntohs(*cp.pu16++);
+	utid = ntohs(*cp.pu16++);
+	usid = ntohs(*cp.pu16++);
+	pstate->remns = ntohs(*cp.pu16++);
+	pstate->remnr = ntohs(*cp.pu16++);
 
-void wrong_length (struct call *c, char *field, int expected, int found,
-                   int min)
-{
-    if (min)
-        snprintf (c->errormsg, sizeof (c->errormsg),
-                  "%s: expected at least %d, got %d", field, expected, found);
-    else
-        snprintf (c->errormsg, sizeof (c->errormsg),
-                  "%s: expected %d, got %d", field, expected, found);
+	if( ulen != upktlen ) return -8; /* invalid packet len */
 
-    c->error = ERROR_LENGTH;
-    c->result = RESULT_ERROR;
-    c->needclose = -1;
-}
+	if( pstate->tid && utid != pstate->tid ) return -9; /* invalid tid */
+//	if( pstate->sid && usid != pstate->sid ) return -9; /* no need, only one session per handle */
 
-struct unaligned_u16 {
-	_u16	s;
-} __attribute__((packed));
+	ulen -= (uint16_t)(cp.pu8 - pdata);
 
-/*
- * t, c, data, and datalen may be assumed to be defined for all avp's
- */
+	while( ulen >= L2TP_AVP_HLEN ) { /* avp minimal lenght is 6 */
+		if( !(pavp = (PL2TP_AVP)malloc(sizeof(L2TP_AVP))) ) goto error;
+		memset(pavp, 0, sizeof(L2TP_AVP));
 
-int message_type_avp (struct tunnel *t, struct call *c, void *data,
-                      int datalen)
-{
-    /*
-     * This will be with every control message.  It is critical that this
-     * procedure check for the validity of sending this kind of a message
-     * (assuming sanity check)
-     */
+		uhead = ntohs(*cp.pu16++);
 
-    struct unaligned_u16 *raw = data;
-    c->msgtype = ntohs (raw[3].s);
-    if (datalen != 8)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: wrong size (%d != 8)\n", __FUNCTION__,
-                 datalen);
-        wrong_length (c, "Message Type", 8, datalen, 0);
-        return -EINVAL;
-    }
-    if ((c->msgtype > MAX_MSG) || (!msgtypes[c->msgtype]))
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: unknown message type %d\n", __FUNCTION__,
-                 c->msgtype);
-        return -EINVAL;
-    }
-    if (gconfig.debug_avp)
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: message type %d (%s)\n", __FUNCTION__,
-                 c->msgtype, msgtypes[c->msgtype]);
-#ifdef SANITY
-    if (t->sanity)
-    {
-        /*
-         * Look ou our state for each message and make sure everything
-         * make sense...
-         */
-        if ((c != t->self) && (c->msgtype < Hello))
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: attempting to negotiate tunnel inside a call!\n",
-                     __FUNCTION__);
-            return -EINVAL;
-        }
+		pavp->umand = (uhead & L2TP_AVP_MBIT) ? 1 : 0;
+		pavp->uhidden = (uhead & L2TP_AVP_HBIT) ? 1 : 0;
+		pavp->ulen = (uhead & 0x3ff);
 
-        switch (c->msgtype)
-        {
-        case SCCRQ:
-            if ((t->state != 0) && (t->state != SCCRQ))
-            {
-                /*
-                 * When we handle tie breaker AVP's, then we'll check
-                 * to see if we've both requested tunnels
-                 */
+		pavp->uvendor = ntohs(*cp.pu16++);
+		pavp->utype = ntohs(*cp.pu16++);
 
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate SCCRQ with state != 0\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case SCCRP:
-            if (t->state != SCCRQ)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate SCCRP with state != SCCRQ!\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case SCCCN:
-            if (t->state != SCCRP)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate SCCCN with state != SCCRP!\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case ICRQ:
-            if (t->state != SCCCN)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate ICRQ when state != SCCCN\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            if (c != t->self)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate ICRQ on a call!\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case ICRP:
-            if (t->state != SCCCN)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate ICRP on tunnel!=SCCCN\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            if (c->state != ICRQ)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate ICRP when state != ICRQ\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case ICCN:
-            if (c->state != ICRP)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate ICCN when state != ICRP\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case SLI:
-            if (c->state != ICCN)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate SLI when state != ICCN\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case OCRP:             /* jz: case for ORCP */
-            if (t->state != SCCCN)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate OCRP on tunnel!=SCCCN\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            if (c->state != OCRQ)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate OCRP when state != OCRQ\n",
-                         __FUNCTION__);
-                return -EINVAL;
+		if( pavp->ulen > L2TP_AVP_HLEN && ulen >= pavp->ulen ) {
+			memcpy(pavp->udata, cp.pu8, pavp->ulen - L2TP_AVP_HLEN);
+			cp.pu8 += (pavp->ulen - L2TP_AVP_HLEN);
             }
-            break;
-        case OCCN:             /* jz: case for OCCN */
 
-            if (c->state != OCRQ)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: attempting to negotiate OCCN when state != OCRQ\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-            break;
-        case StopCCN:
-        case CDN:
-        case Hello:
-            break;
-        default:
-            l2tp_log (LOG_WARNING, "%s: i don't know how to handle %s messages\n",
-                 __FUNCTION__, msgtypes[c->msgtype]);
-            return -EINVAL;
-        }
-    }
-#endif
-    if (c->msgtype == ICRQ)
-    {
-        struct call *tmp;
-        if (gconfig.debug_avp)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG, "%s: new incoming call\n", __FUNCTION__);
-        }
-        tmp = new_call (t);
-        if (!tmp)
-        {
-            l2tp_log (LOG_WARNING, "%s: unable to create new call\n", __FUNCTION__);
-            return -EINVAL;
-        }
-        tmp->next = t->call_head;
-        t->call_head = tmp;
-        t->count++;
-        /*
-           * Is this still safe to assume that the head will always
-           * be the most recent call being negotiated?
-           * Probably...  FIXME anyway...
-         */
+		if( ulen >= pavp->ulen ) ulen -= pavp->ulen;
+		else ulen = 0;
 
+		if( !pavp_head ) pavp_head = pavp_tail = pavp;
+		else pavp_tail = pavp_tail->pnext = pavp;
     }
 
-    return 0;
-}
+	*ppres = pavp_head;
 
-int rand_vector_avp (struct tunnel *t, struct call *c, void *data,
-                     int datalen)
-{
-    int size;
-    struct unaligned_u16 *raw = data;
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-#ifdef SANITY
-    if (t->sanity)
-    {
-        if (size < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG, "%s: Random vector too small (%d < 0)\n",
-                     __FUNCTION__, size);
-            wrong_length (c, "Random Vector", 6, datalen, 1);
-            return -EINVAL;
-        }
-        if (size > MAX_VECTOR_SIZE)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG, "%s: Random vector too large (%d > %d)\n",
-                     __FUNCTION__, datalen, MAX_VECTOR_SIZE);
-            wrong_length (c, "Random Vector", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    if (gconfig.debug_avp)
-        l2tp_log (LOG_DEBUG, "%s: Random Vector of %d octets\n", __FUNCTION__,
-             size);
-    t->chal_us.vector = (unsigned char *) &raw[3].s;
-    t->chal_us.vector_len = size;
     return 0;
-}
 
-int ignore_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * The spec says we have to accept authentication information
-     * even if we just ignore it, so that's exactly what
-     * we're going to do at this point.  Proxy authentication is such
-     * a rediculous security threat anyway except from local
-     * controled machines.
-     *
-     * FIXME: I need to handle proxy authentication as an option.
-     * One option is to simply change the options we pass to pppd.
-     *
-     */
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s : Ignoring AVP\n", __FUNCTION__);
+error:
+	while( (pavp = pavp_head) ) {
+		pavp_head = pavp_head->pnext;
+		free(pavp);
     }
-    return 0;
-}
 
-int seq_reqd_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-#ifdef SANITY
-    if (t->sanity)
-    {
-        if (datalen != 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Sequencing Required", 6, datalen, 1);
-            return -EINVAL;
-        }
-        switch (c->msgtype)
-        {
-        case ICCN:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: sequencing required not appropriate for %s!\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return -EINVAL;
-        }
-    }
-#endif
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: peer requires sequencing.\n", __FUNCTION__);
-    }
-    c->seq_reqd = -1;
-    return 0;
+	return -10;
 }
 
-int result_code_avp (struct tunnel *t, struct call *c, void *data,
-                     int datalen)
-{
-    /*
-     * Find out what version of l2tp the other side is using.
-     * I'm not sure what we're supposed to do with this but whatever..
-     */
+int l2tp_avp_build_pkt(PL2TP_STATE pstate, uint8_t **ppdata, PL2TP_AVP pavp) {
+	uint32_t upktlen;
+	PL2TP_AVP pavp_cur;
+	uint8_t *ppkt;
+	uint16_t uhead;
+	COMMON_POINTER cp;
 
-    int error;
-    int result;
-    struct unaligned_u16 *raw = data;
-#ifdef SANITY
-    if (t->sanity)
-    {
-        if (datalen < 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d < 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Result Code", 10, datalen, 1);
-            return -EINVAL;
-        }
-        switch (c->msgtype)
-        {
-        case CDN:
-        case StopCCN:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: result code not appropriate for %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-    }
-#endif
-    result = ntohs (raw[3].s);
-    error = ntohs (raw[4].s);
-    if ((c->msgtype == StopCCN) && ((result > 7) || (result < 1)))
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: result code out of range (%d %d %d).  Ignoring.\n",
-                 __FUNCTION__, result, error, datalen);
-        return 0;
+	pavp_cur = pavp;
+	upktlen = 0;
+	while( pavp_cur ) {
+		upktlen += pavp_cur->ulen;
+		pavp_cur = pavp_cur->pnext;
     }
 
-    if ((c->msgtype == CDN) && ((result > 11) || (result < 1)))
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: result code out of range (%d %d %d).  Ignoring.\n",
-                 __FUNCTION__, result, error, datalen);
-        return 0;
-    }
+	upktlen += L2TP_HLEN;
+	*ppdata = NULL;
 
-    c->error = error;
-    c->result = result;
-    safe_copy (c->errormsg, (char *) &raw[5].s, datalen - 10);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG && (c->msgtype == StopCCN))
-        {
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer closing for reason %d (%s), error = %d (%s)\n",
-                 __FUNCTION__, result, stopccn_result_codes[result], error,
-                 c->errormsg);
-        }
-        else
-        {
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer closing for reason %d (%s), error = %d (%s)\n",
-                 __FUNCTION__, result, cdn_result_codes[result], error,
-                 c->errormsg);
-        }
-    }
-    return 0;
-}
+	if( !(ppkt = (uint8_t *)malloc(upktlen)) ) return -1;
+	memset(ppkt, 0, upktlen);
 
-int protocol_version_avp (struct tunnel *t, struct call *c, void *data,
-                          int datalen)
-{
-    /*
-     * Find out what version of l2tp the other side is using.
-     * I'm not sure what we're supposed to do with this but whatever..
-     */
+	cp.pu8 = ppkt;
 
-    int ver;
-    struct unaligned_u16 *raw = data;
-#ifdef SANITY
-    if (t->sanity)
-    {
-        if (datalen != 8)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 8\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Protocol Version", 8, datalen, 1);
-            return -EINVAL;
-        }
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: protocol version not appropriate for %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-    }
-#endif
-    ver = ntohs (raw[3].s);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer is using version %d, revision %d.\n", __FUNCTION__,
-                 (ver >> 8), ver & 0xFF);
-    }
-    return 0;
-}
+	uhead = L2TP_TBIT | L2TP_LBIT | L2TP_SBIT | L2TP_VERSION;
 
-int framing_caps_avp (struct tunnel *t, struct call *c, void *data,
-                      int datalen)
-{
-    /*
-     * Retrieve the framing capabilities
-     * from the peer
-     */
+	*cp.pu16++ = htons(uhead);
+	*cp.pu16++ = htons(upktlen);
+	*cp.pu16++ = htons(pstate->remtid);
 
-    int caps;
-    struct unaligned_u16 *raw = data;
+	if( ( pavp && (pavp->utype != 0 || ntohs(*(unsigned short *)pavp->udata) != AVP_MT_HELLO) ) || pstate->acksid ) {
+		if( pstate->acksid ) *cp.pu16++ = htons(pstate->acksid);
+		else *cp.pu16++ = htons(pstate->remsid);
+		pstate->acksid = 0;
+	} else *cp.pu16++ = 0;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: framing capabilities not appropriate for %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Framming Capabilities", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    caps = ntohs (raw[4].s);
-    if (gconfig.debug_avp)
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: supported peer frames:%s%s\n", __FUNCTION__,
-                 caps & ASYNC_FRAMING ? " async" : "",
-                 caps & SYNC_FRAMING ? " sync" : "");
-    t->fc = caps & (ASYNC_FRAMING | SYNC_FRAMING);
-    return 0;
-}
+	*cp.pu16++ = htons(pstate->ns);
+	*cp.pu16++ = htons(pstate->nr);
 
-int bearer_caps_avp (struct tunnel *t, struct call *c, void *data,
-                     int datalen)
-{
-    /*
-     * What kind of bearer channels does our peer support?
-     */
-    int caps;
-    struct unaligned_u16 *raw = data;
+	while( (pavp_cur = pavp) ) {
+		uhead = 0;
+		if( pavp_cur->umand ) uhead |= L2TP_AVP_MBIT;
+		if( pavp_cur->uhidden ) uhead |= L2TP_AVP_HBIT;
+		uhead |= (pavp_cur->ulen & 0x3ff);
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: bearer capabilities not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Bearer Capabilities", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    caps = ntohs (raw[4].s);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-        {
-            l2tp_log (LOG_DEBUG,
-                 "%s: supported peer bearers:%s%s\n",
-                 __FUNCTION__,
-                 caps & ANALOG_BEARER ? " analog" : "",
-                 caps & DIGITAL_BEARER ? " digital" : "");
-        }
+		*cp.pu16++ = htons(uhead);
+		*cp.pu16++ = htons(pavp_cur->uvendor);
+		*cp.pu16++ = htons(pavp_cur->utype);
 
+		if( pavp_cur->ulen > L2TP_AVP_HLEN ) {
+			memcpy(cp.pu8, pavp_cur->udata, pavp_cur->ulen - L2TP_AVP_HLEN);
+			cp.pu8 += (pavp_cur->ulen - L2TP_AVP_HLEN);
     }
-    t->bc = caps & (ANALOG_BEARER | DIGITAL_BEARER);
-    return 0;
-}
-
-
-/* FIXME: I need to handle tie breakers eventually */
-
-int firmware_rev_avp (struct tunnel *t, struct call *c, void *data,
-                      int datalen)
-{
-    /*
-     * Report and record remote firmware version
-     */
-    int ver;
-    struct unaligned_u16 *raw = data;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: firmware revision not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 8)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 8\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Firmware Revision", 8, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    ver = ntohs (raw[3].s);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer reports firmware version %d (0x%.4x)\n",
-                 __FUNCTION__, ver, ver);
+		pavp = pavp->pnext;
+		free(pavp_cur);
     }
-    t->firmware = ver;
-    return 0;
-}
 
-int bearer_type_avp (struct tunnel *t, struct call *c, void *data,
-                     int datalen)
-{
-    /*
-     * What kind of bearer channel is the call on?
-     */
-    int b;
-    struct unaligned_u16 *raw = data;
+	*ppdata = ppkt;
+	return (int)upktlen;
+}
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICRQ:
-        case OCRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: bearer type not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Bearer Type", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    b = ntohs (raw[4].s);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer bears:%s\n", __FUNCTION__,
-                 b & ANALOG_BEARER ? " analog" : "digital");
+void l2tp_avp_free_pkt(uint8_t **ppdata) {
+	if( *ppdata ) {
+		free(*ppdata);
+		*ppdata = NULL;
     }
-    t->call_head->bearer = b;
-    return 0;
 }
 
-int frame_type_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * What kind of frame channel is the call on?
-     */
-    int b;
-    struct unaligned_u16 *raw = data;
+PL2TP_AVP l2tp_avp_add(PL2TP_AVP ptail, uint16_t utype, uint8_t *pdata, uint32_t ulen) {
+	PL2TP_AVP pavp;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICCN:
-        case OCRQ:
-        case OCCN:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: frame type not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is incorrect size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Frame Type", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    b = ntohs (raw[4].s);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer uses:%s frames\n", __FUNCTION__,
-                 b & ASYNC_FRAMING ? " async" : "sync");
-    }
-    c->frame = b;
-    return 0;
+	if( !(pavp = (PL2TP_AVP)malloc(sizeof(L2TP_AVP))) ) return NULL;
+	memset(pavp, 0, sizeof(L2TP_AVP));
+	pavp->umand = 1;
+	pavp->ulen =  (ulen + L2TP_AVP_HLEN) & 0x3ff;
+	pavp->utype = utype;
+	memcpy(pavp->udata, pdata, ulen);
+	
+	if( ptail ) ptail->pnext = pavp;
+	return pavp;
 }
 
-int hostname_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * What is the peer's name?
-     */
-    int size;
-    struct unaligned_u16 *raw = data;
+void l2tp_avp_free_list(PL2TP_AVP pavp_head) {
+	PL2TP_AVP pavp;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: hostname not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Hostname", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    if (size > MAXSTRLEN - 1)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: truncating reported hostname (size is %d)\n",
-                 __FUNCTION__, size);
-        size = MAXSTRLEN - 1;
-    }
-    safe_copy (t->hostname, (char *) &raw[3].s, size);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer reports hostname '%s'\n", __FUNCTION__,
-                 t->hostname);
+	while( (pavp = pavp_head) ) {
+		pavp_head = pavp_head->pnext;
+		free(pavp);
     }
-    return 0;
 }
 
-int dialing_number_avp (struct tunnel *t, struct call *c, void *data,
-                        int datalen)
-{
-    /*
-     * What is the peer's name?
-     */
-    int size;
-    struct unaligned_u16 *raw = data;
+PL2TP_AVP l2tp_avp_find(PL2TP_AVP phead, uint16_t utype) {
+	PL2TP_AVP pavp = phead;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: dialing number not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Dialing Number", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    if (size > MAXSTRLEN - 1)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: truncating reported dialing number (size is %d)\n",
-                 __FUNCTION__, size);
-        size = MAXSTRLEN - 1;
-    }
-    safe_copy (t->call_head->dialing, (char *) &raw[3].s, size);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer reports dialing number '%s'\n", __FUNCTION__,
-                 t->call_head->dialing);
-    }
-    return 0;
+	while( pavp ) 
+		if( pavp->utype == utype ) break;
+		else pavp = pavp->pnext;
+	
+	return pavp;
 }
 
-int dialed_number_avp (struct tunnel *t, struct call *c, void *data,
-                       int datalen)
-{
-    /*
-     * What is the peer's name?
-     */
-    int size;
-    struct unaligned_u16 *raw = data;
+int l2tp_avp_build_req(PL2TP_STATE pstate, uint16_t utype, uint8_t **ppdata) {
+	PL2TP_AVP phead, ptail;
+	int istep;
+	COMMON_POINTER cp;
+	uint8_t udata[L2TP_MAVP_LEN];
+	uint8_t *ptypes;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case OCRQ:
-        case ICRQ:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: dialed number not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Dialed Number", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    if (size > MAXSTRLEN - 1)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: truncating reported dialed number (size is %d)\n",
-                 __FUNCTION__, size);
-        size = MAXSTRLEN - 1;
-    }
-    safe_copy (t->call_head->dialed, (char *) &raw[3].s, size);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer reports dialed number '%s'\n", __FUNCTION__,
-                 t->call_head->dialed);
-    }
-    return 0;
-}
+	uint8_t utypes_sccrq[] = {AVP_ATTR_MESSAGE_TYPE, AVP_ATTR_PROTO_VERSION, AVP_ATTR_HOST_NAME, AVP_ATTR_FRAME_CAP, AVP_ATTR_ASSIGN_TUN, 0xFF};
+	uint8_t utypes_scccn[] = {AVP_ATTR_MESSAGE_TYPE, 0xFF};
+	uint8_t utypes_icrq[] = {AVP_ATTR_MESSAGE_TYPE, AVP_ATTR_ASSIGN_SES, AVP_ATTR_SERNUM, 0xFF};
+	uint8_t utypes_iccn[] = {AVP_ATTR_MESSAGE_TYPE, AVP_ATTR_FRAME_TYPE, AVP_ATTR_TXSPEED, AVP_ATTR_RXSPEED, 0xFF};
+	uint8_t utypes_cdn[] = {AVP_ATTR_MESSAGE_TYPE, AVP_ATTR_ASSIGN_SES, AVP_ATTR_RESULT_CODE, 0xFF};
+	uint8_t utypes_stopccn[] = {AVP_ATTR_MESSAGE_TYPE, AVP_ATTR_ASSIGN_TUN, AVP_ATTR_RESULT_CODE, 0xFF};
+	uint8_t utypes_zlb[] = { 0xFF };
+	uint8_t utypes_hello[] = {AVP_ATTR_MESSAGE_TYPE, 0xFF};
 
-int sub_address_avp (struct tunnel *t, struct call *c, void *data,
-                     int datalen)
-{
-    /*
-     * What is the peer's name?
-     */
-    int size;
-    struct unaligned_u16 *raw = data;
+	phead = ptail = NULL;
+	istep = 0;
+	*ppdata = NULL;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case OCRP:
-        case ICRQ:
+	switch( utype ) {
+	case AVP_MT_SCCRQ:
+		ptypes = utypes_sccrq;
+		break;
+	case AVP_MT_SCCCN:
+		ptypes = utypes_scccn;
+		break;
+	case AVP_MT_ICRQ:
+		ptypes = utypes_icrq;
+		break;
+	case AVP_MT_ICCN:
+		ptypes = utypes_iccn;
+		break;
+	case AVP_MT_CDN:
+		ptypes = utypes_cdn;
+		break;
+	case AVP_MT_STOPCCN:
+		ptypes = utypes_stopccn;
+		break;
+	case AVP_MT_HELLO:
+		ptypes = utypes_hello;
+		break;
+	default: /* ZLB */
+		ptypes = utypes_zlb;
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: sub_address not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Sub-address", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    if (size > MAXSTRLEN - 1)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: truncating reported sub address (size is %d)\n",
-                 __FUNCTION__, size);
-        size = MAXSTRLEN - 1;
-    }
-    safe_copy (t->call_head->subaddy, (char *) &raw[3].s, size);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer reports subaddress '%s'\n", __FUNCTION__,
-                 t->call_head->subaddy);
     }
-    return 0;
-}
 
-int vendor_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * What vendor makes the other end?
-     */
-    int size;
-    struct unaligned_u16 *raw = data;
+	while( ptypes[istep] != 0xFF ) {
+		cp.pu8 = udata;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
+		switch( ptypes[istep] ) {
+		case AVP_ATTR_MESSAGE_TYPE:
+			*cp.pu16++ = htons(utype);
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: vendor not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Vendor", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    if (size > MAXSTRLEN - 1)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: truncating reported vendor (size is %d)\n",
-                 __FUNCTION__, size);
-        size = MAXSTRLEN - 1;
-    }
-    safe_copy (t->vendor, (char *) &raw[3].s, size);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer reports vendor '%s'\n", __FUNCTION__, t->vendor);
-    }
-    return 0;
-}
-
-int challenge_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * We are sent a challenge
-     */
-    struct unaligned_u16 *raw = data;
-    int size;
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
+		case AVP_ATTR_PROTO_VERSION:
+			*cp.pu8++ = 1; /* version */
+			*cp.pu8++ = 0; /* revision */
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: challenge not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "challenge", 6, datalen, 1);
-            return -EINVAL;
+		case AVP_ATTR_HOST_NAME:
+			strcpy(cp.p8, pstate->chostname);
+			cp.p8 += strlen(pstate->chostname);
+			break;
+		case AVP_ATTR_FRAME_CAP:
+			*cp.pu32++ = htonl(0x1); /* sync only */
+			break;
+		case AVP_ATTR_FRAME_TYPE:
+			*cp.pu32++ = htonl(0x1); /* sync only */
+			break;
+		case AVP_ATTR_ASSIGN_TUN:
+			if( !pstate->tid ) {
+				srand(time(NULL));
+				pstate->tid = rand() % 65535;
         }
+			*cp.pu16++ = htons(pstate->tid);
+			break;
+		case AVP_ATTR_ASSIGN_SES:
+			if( !pstate->sid ) {
+				srand(time(NULL));
+				pstate->sid = rand() % 32768;
     }
-#endif
-    /* size = raw[0].s & 0x0FFF; */
-    /* length field of AVP's is only 10 bits long, not 12 */
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    /* if (size != MD_SIG_SIZE)
-    {
-        l2tp_log (LOG_DEBUG, "%s: Challenge is not the right length (%d != %d)\n",
-             __FUNCTION__, size, MD_SIG_SIZE);
-        return -EINVAL;
-    } */
-    if (t->chal_us.challenge)
-	free(t->chal_us.challenge);
-    t->chal_us.challenge = zalloc(size);
-    if (t->chal_us.challenge == NULL)
-    {
-        return -ENOMEM;
+			*cp.pu16++ = htons(pstate->sid);
+			break;
+		case AVP_ATTR_RESULT_CODE:
+			*cp.pu16++ = htonl(0x1); /* term control req */
+			*cp.pu16++ = htonl(0x0); /* no error */
+			break;
+		case AVP_ATTR_SERNUM:
+			*cp.pu32++ = htonl(0x1); /* serial number is one as is */
+			break;
+		case AVP_ATTR_TXSPEED:
+			*cp.pu32++ = htonl(1000 * 1024 * 1024); /* max speed is 1gbit */
+			break;
+		case AVP_ATTR_RXSPEED:
+			*cp.pu32++ = htonl(1000 * 1024 * 1024); /* max speed is 1gbit */
+			break;
     }
-    bcopy (&raw[3].s, (t->chal_us.challenge), size);
-    t->chal_us.chal_len = size;
-    t->chal_us.state = STATE_CHALLENGED;
-    if (gconfig.debug_avp)
-    {
-        l2tp_log (LOG_DEBUG, "%s: challenge avp found\n", __FUNCTION__);
+			
+		ptail = l2tp_avp_add(ptail, ptypes[istep], udata, (uint32_t)(cp.pu8 - udata));
+		if( !phead ) phead = ptail;
+		istep++;
     }
-    return 0;
-}
 
-int chalresp_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * We are sent a challenge
-     */
-    struct unaligned_u16 *raw = data;
-    int size;
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCCN:
+	switch( utype ) {
+	case AVP_MT_STOPCCN:
+		pstate->remsid = 0;
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: challenge response not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen < 6)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is too small.  %d < 6\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "challenge", 6, datalen, 1);
-            return -EINVAL;
-        }
-    }
-#endif
-    size = raw[0].s & 0x03FF;
-    size -= sizeof (struct avp_hdr);
-    if (size != MD_SIG_SIZE)
-    {
-        l2tp_log (LOG_DEBUG, "%s: Challenge is not the right length (%d != %d)\n",
-             __FUNCTION__, size, MD_SIG_SIZE);
-        return -EINVAL;
     }
 
-    bcopy (&raw[3].s, t->chal_them.reply, MD_SIG_SIZE);
-    if (gconfig.debug_avp)
-    {
-        l2tp_log (LOG_DEBUG, "%s: Challenge reply found\n", __FUNCTION__);
-    }
-    return 0;
+	return l2tp_avp_build_pkt(pstate, ppdata, phead);
 }
 
-int assigned_tunnel_avp (struct tunnel *t, struct call *c, void *data,
-                         int datalen)
-{
-    /*
-     * What is their TID that we must use from now on?
-     */
-    struct unaligned_u16 *raw = data;
+int l2tp_avp_parse_res(PL2TP_STATE pstate, uint16_t utype, const uint8_t *pdata, uint32_t ulen) {
+	PL2TP_AVP phead, pavp;
+	int iret;
+	COMMON_POINTER cp;
+	uint16_t mt, tid, sid;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-        case StopCCN:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: tunnel ID not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 8)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Assigned Tunnel ID", 8, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    if (c->msgtype == StopCCN)
-    {
-        t->qtid = ntohs (raw[3].s);
-    }
-    else
-    {
-        t->tid = ntohs (raw[3].s);
-    }
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: using peer's tunnel %d\n", __FUNCTION__,
-                 ntohs (raw[3].s));
+	if( (iret = l2tp_avp_parse(pstate, (const uint8_t *)pdata, ulen, &phead)) < 0 ) 
+		return iret;
+		
+	if( utype == 0xFF && !phead ) {
+		return 0; /* zlb */
     }
-    return 0;
-}
 
-int assigned_call_avp (struct tunnel *t, struct call *c, void *data,
-                       int datalen)
-{
-    /*
-     * What is their CID that we must use from now on?
-     */
-    struct unaligned_u16 *raw = data;
+	if( !(pavp = l2tp_avp_find(phead, AVP_ATTR_MESSAGE_TYPE)) ) 
+		goto error;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case CDN:
-        case ICRP:
-        case ICRQ:
-        case OCRP:             /* jz: deleting the debug message */
-            break;
-        case OCRQ:
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: call ID not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 8)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Assigned Call ID", 8, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    if (c->msgtype == CDN)
-    {
-        c->qcid = ntohs (raw[3].s);
-    }
-    else if (c->msgtype == ICRQ)
-    {
-        t->call_head->cid = ntohs (raw[3].s);
-    }
-    else if (c->msgtype == ICRP)
-    {
-        c->cid = ntohs (raw[3].s);
-    }
-    else if (c->msgtype == OCRP)
-    {                           /* jz: copy callid to c->cid */
-        c->cid = ntohs (raw[3].s);
-    }
-    else
-    {
-        l2tp_log (LOG_DEBUG, "%s:  Dunno what to do when it's state %s!\n",
-             __FUNCTION__, msgtypes[c->msgtype]);
-    }
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: using peer's call %d\n", __FUNCTION__, ntohs (raw[3].s));
-    }
-    return 0;
-}
+	cp.pu8 = pavp->udata;
+	mt = ntohs(*cp.pu16);
 
-int packet_delay_avp (struct tunnel *t, struct call *c, void *data,
-                      int datalen)
-{
-    /*
-     * What is their CID that we must use from now on?
-     */
-    struct unaligned_u16 *raw = data;
+	if( mt != utype ) goto error;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICRP:
-        case OCRQ:
-        case ICCN:
-        case OCRP:
-        case OCCN:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: packet delay not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 8)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Assigned Call ID", 8, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    c->ppd = ntohs (raw[3].s);
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer's delay is %d 1/10's of a second\n", __FUNCTION__,
-                 ntohs (raw[3].s));
+	switch( utype ) {
+	case AVP_MT_SCCRP:
+		if( !(pavp = l2tp_avp_find(phead, AVP_ATTR_ASSIGN_TUN)) ) {
+			info("l2tp: sccrp, no attr - AVP_ATTR_ASSIGN_TUN\n");
+			goto error;
     }
-    return 0;
-}
 
-int call_serno_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * What is the serial number of the call?
-     */
-    struct unaligned_u16 *raw = data;
+		cp.pu8 = pavp->udata;
+		tid = ntohs(*cp.pu16);
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICRQ:
-        case OCRQ:
+		pstate->remtid = tid;
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: call ID not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
+	case AVP_MT_ICRP:
+		if( !(pavp = l2tp_avp_find(phead, AVP_ATTR_ASSIGN_SES)) ) {
+			info("l2tp: icrp, no attr - AVP_ATTR_ASSIGN_SES\n");
+			goto error;
         }
-        if (datalen != 10)
-        {
-#ifdef STRICT
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Serial Number", 10, datalen, 0);
-            return -EINVAL;
-#else
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer is using old style serial number.  Will be invalid.\n",
-                 __FUNCTION__);
-#endif
 
-        }
-    }
-#endif
-    t->call_head->serno = (((unsigned int) ntohs (raw[3].s)) << 16) |
-        ((unsigned int) ntohs (raw[4].s));
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: serial number is %d\n", __FUNCTION__,
-                 t->call_head->serno);
-    }
-    return 0;
-}
+		cp.pu8 = pavp->udata;
+		sid = ntohs(*cp.pu16);
 
-int rx_speed_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * What is the received baud rate of the call?
-     */
-    struct unaligned_u16 *raw = data;
+		pstate->remsid = sid;
+		break;
+	case AVP_MT_HELLO:
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICCN:
-        case OCCN:
-        case OCRP:
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: rx connect speed not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Connect Speed (RX)", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    c->rxspeed = (((unsigned int) ntohs (raw[3].s)) << 16) |
-        ((unsigned int) ntohs (raw[4].s));
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: receive baud rate is %d\n", __FUNCTION__, c->rxspeed);
-    }
-    return 0;
-}
+	case AVP_MT_CDN:
+		if( !(pavp = l2tp_avp_find(phead, AVP_ATTR_ASSIGN_SES)) ) 
+			goto error;
 
-int tx_speed_avp (struct tunnel *t, struct call *c, void *data, int datalen)
-{
-    /*
-     * What is the tranmsit baud rate of the call?
-     */
-    struct unaligned_u16 *raw = data;
+		cp.pu8 = pavp->udata;
+		sid = ntohs(*cp.pu16);
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICCN:
-        case OCCN:
-        case OCRP:
-            break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: tx connect speed not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Connect Speed (tx)", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    c->txspeed = (((unsigned int) ntohs (raw[3].s)) << 16) |
-        ((unsigned int) ntohs (raw[4].s));
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: transmit baud rate is %d\n", __FUNCTION__, c->txspeed);
-    }
-    return 0;
-}
-int call_physchan_avp (struct tunnel *t, struct call *c, void *data,
-                       int datalen)
-{
-    /*
-     * What is the physical channel?
-     */
-    struct unaligned_u16 *raw = data;
+		if( pstate->remsid != sid )
+			goto error;
+			
+		pstate->acksid = pstate->remsid;
+		pstate->remsid = 0;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case ICRQ:
-        case OCRQ:
-        case OCRP:
-        case OCCN:
             break;
-        default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: physical channel not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 10)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 10\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Physical Channel", 10, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    t->call_head->physchan = (((unsigned int) ntohs (raw[3].s)) << 16) |
-        ((unsigned int) ntohs (raw[4].s));
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: physical channel is %d\n", __FUNCTION__,
-                 t->call_head->physchan);
-    }
-    return 0;
-}
+  	case AVP_MT_STOPCCN:
+		if( !(pavp = l2tp_avp_find(phead, AVP_ATTR_ASSIGN_TUN)) ) 
+			goto error;
 
-int receive_window_size_avp (struct tunnel *t, struct call *c, void *data,
-                             int datalen)
-{
-    /*
-     * What is their RWS?
-     */
-    struct unaligned_u16 *raw = data;
+		cp.pu8 = pavp->udata;
+		tid = ntohs(*cp.pu16);
+	
+		if( pstate->remtid != tid )
+			goto error;
 
-#ifdef SANITY
-    if (t->sanity)
-    {
-        switch (c->msgtype)
-        {
-        case SCCRP:
-        case SCCRQ:
-        case OCRP:             /* jz */
-        case OCCN:             /* jz */
-        case StopCCN:
-/*		case ICRP:
-		case ICCN: */
             break;
         default:
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: RWS not appropriate for message %s.  Ignoring.\n",
-                     __FUNCTION__, msgtypes[c->msgtype]);
-            return 0;
-        }
-        if (datalen != 8)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: avp is wrong size.  %d != 8\n", __FUNCTION__,
-                     datalen);
-            wrong_length (c, "Receive Window Size", 8, datalen, 0);
-            return -EINVAL;
-        }
-    }
-#endif
-    t->rws = ntohs (raw[3].s);
-/*	if (c->rws >= 0)
-		c->fbit = FBIT; */
-    if (gconfig.debug_avp)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: peer wants RWS of %d.  Will use flow control.\n",
-                 __FUNCTION__, t->rws);
+		goto error;
     }
+	
+	l2tp_avp_free_list(phead);
     return 0;
+	
+error:
+	l2tp_avp_free_list(phead);
+	return -20;
 }
 
 
-int handle_avps (struct buffer *buf, struct tunnel *t, struct call *c)
-{
-    /*
-     * buf's start should point to the beginning of a packet. We assume it's
-     * a valid packet and has had check_control done to it, so no error
-     * checking is done at this point.
-     */
-
-    struct avp_hdr *avp;
-    int len = buf->len - sizeof (struct control_hdr);
-    int firstavp = -1;
-    int hidlen = 0;
-    char *data = buf->start + sizeof (struct control_hdr);
-    avp = (struct avp_hdr *) data;
-    if (gconfig.debug_avp)
-        l2tp_log (LOG_DEBUG, "%s: handling avp's for tunnel %d, call %d\n",
-             __FUNCTION__, t->ourtid, c->ourcid);
-    while (len > 0)
-    {
-        /* Go ahead and byte-swap the header */
-        swaps (avp, sizeof (struct avp_hdr));
-        if (avp->attr > AVP_MAX)
-        {
-            if (AMBIT (avp->length))
-            {
-                l2tp_log (LOG_WARNING,
-                     "%s:  dont know how to handle mandatory attribute %d.  Closing %s.\n",
-                     __FUNCTION__, avp->attr,
-                     (c != t->self) ? "call" : "tunnel");
-                set_error (c, VENDOR_ERROR,
-                           "mandatory attribute %d cannot be handled",
-                           avp->attr);
-                c->needclose = -1;
-                return -EINVAL;
-            }
-            else
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_WARNING,
-                         "%s:  dont know how to handle atribute %d.\n",
-                         __FUNCTION__, avp->attr);
-                goto next;
-            }
-        }
-        if (ALENGTH (avp->length) > len)
-        {
-            l2tp_log (LOG_WARNING,
-                 "%s: AVP received with length > remaining packet length!\n",
-                 __FUNCTION__);
-            set_error (c, ERROR_LENGTH, "Invalid AVP length");
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        if (avp->attr && firstavp)
-        {
-            l2tp_log (LOG_WARNING, "%s: First AVP was not message type.\n",
-                 __FUNCTION__);
-            set_error (c, VENDOR_ERROR, "First AVP must be message type");
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        if (ALENGTH (avp->length) < sizeof (struct avp_hdr))
-        {
-            l2tp_log (LOG_WARNING, "%s: AVP with too small of size (%d).\n",
-                 __FUNCTION__, ALENGTH (avp->length));
-            set_error (c, ERROR_LENGTH, "AVP too small");
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        if (AZBITS (avp->length))
-        {
-            l2tp_log (LOG_WARNING, "%s: %sAVP has reserved bits set.\n", __FUNCTION__,
-                 AMBIT (avp->length) ? "Mandatory " : "");
-            if (AMBIT (avp->length))
-            {
-                set_error (c, ERROR_RESERVED, "reserved bits set in AVP");
-                c->needclose = -1;
-                return -EINVAL;
-            }
-            goto next;
-        }
-        if (AHBIT (avp->length))
-        {
-#ifdef DEBUG_HIDDEN
-            l2tp_log (LOG_DEBUG, "%s: Hidden bit set on AVP.\n", __FUNCTION__);
-#endif
-            /* We want to rewrite the AVP as an unhidden AVP
-               and then pass it along as normal.  Remeber how
-               long the AVP was in the first place though! */
-            hidlen = avp->length;
-            if (decrypt_avp (data, t))
-            {
-                if (gconfig.debug_avp)
-                    l2tp_log (LOG_WARNING, "%s: Unable to handle hidden %sAVP\n:",
-                         __FUNCTION__,
-                         (AMBIT (avp->length) ? "mandatory " : ""));
-                if (AMBIT (avp->length))
-                {
-                    set_error (c, VENDOR_ERROR, "Invalid Hidden AVP");
-                    c->needclose = -1;
-                    return -EINVAL;
-                }
-                goto next;
-            };
-            len -= 2;
-            hidlen -= 2;
-            data += 2;
-            avp = (struct avp_hdr *) data;
-            /* Now we should look like a normal AVP */
-        }
-        else
-            hidlen = 0;
-        if (avps[avp->attr].handler)
-        {
-            if (avps[avp->attr].handler (t, c, avp, ALENGTH (avp->length)))
-            {
-                if (AMBIT (avp->length))
-                {
-                    l2tp_log (LOG_WARNING,
-                         "%s: Bad exit status handling attribute %d (%s) on mandatory packet.\n",
-                         __FUNCTION__, avp->attr,
-                         avps[avp->attr].description);
-                    c->needclose = -1;
-                    return -EINVAL;
-                }
-                else
-                {
-                    if (DEBUG)
-                        l2tp_log (LOG_DEBUG,
-                             "%s: Bad exit status handling attribute %d (%s).\n",
-                             __FUNCTION__, avp->attr,
-                             avps[avp->attr].description);
-                }
-            }
-        }
-        else
-        {
-            if (AMBIT (avp->length))
-            {
-                l2tp_log (LOG_WARNING,
-                     "%s:  No handler for mandatory attribute %d (%s).  Closing %s.\n",
-                     __FUNCTION__, avp->attr, avps[avp->attr].description,
-                     (c != t->self) ? "call" : "tunnel");
-                set_error (c, VENDOR_ERROR, "No handler for attr %d (%s)\n",
-                           avp->attr, avps[avp->attr].description);
-                return -EINVAL;
-            }
-            else
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_WARNING, "%s:  no handler for atribute %d (%s).\n",
-                         __FUNCTION__, avp->attr,
-                         avps[avp->attr].description);
-            }
-        }
-      next:
-        if (hidlen)
-        {
-            /* Skip over the complete length of the hidden AVP */
-            len -= ALENGTH (hidlen);
-            data += ALENGTH (hidlen);
-        }
-        else
-        {
-            len -= ALENGTH (avp->length);
-            data += ALENGTH (avp->length);      /* Next AVP, please */
-        }
-        avp = (struct avp_hdr *) data;
-        firstavp = 0;
-    }
-    if (len != 0)
-    {
-        l2tp_log (LOG_WARNING, "%s: negative overall packet length\n", __FUNCTION__);
-        return -EINVAL;
-    }
-    return 0;
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/avp.h ppp-2.4.4/pppd/plugins/pppol2tp/avp.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/avp.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/avp.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,144 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Attribute Value Pair structures and
- * definitions
- */
-
-#include "common.h"
-
-struct avp_hdr
-{
-    _u16 length;
-    _u16 vendorid;
-    _u16 attr;
-} __attribute__((packed));
-
-struct avp
-{
-    int num;                    /* Number of AVP */
-    int m;                      /* Set M? */
-    int (*handler) (struct tunnel *, struct call *, void *, int);
-    /* This should handle the AVP
-       taking a tunnel, call, the data,
-       and the length of the AVP as
-       parameters.  Should return 0
-       upon success */
-    char *description;          /* A name, for debugging */
-};
-
-extern int handle_avps (struct buffer *buf, struct tunnel *t, struct call *c);
-
-extern char *msgtypes[];
-
-#define VENDOR_ID 0             /* We don't have any extensions
-                                   so we shoouldn't have to
-                                   worry about this */
-
-/*
- * Macros to extract information from length field of AVP
- */
-
-#define AMBIT(len) (len & 0x8000)       /* Mandatory bit: If this is
-                                           set on an unknown AVP, 
-                                           we MUST terminate */
-
-#define AHBIT(len) (len & 0x4000)       /* Hidden bit: Specifies
-                                           information hiding */
-
-#define AZBITS(len) (len & 0x3C00)      /* Reserved bits:  We must
-                                           drop anything with any
-                                           of these set.  */
-
-#define ALENGTH(len) (len & 0x03FF)     /* Length:  Lenth of AVP */
-
-#define MAXAVPSIZE 1023
-
-#define MAXTIME 300             /* time to wait before checking
-                                   Ns and Nr, in ms */
-
-#define MBIT 0x8000             /* for setting */
-#define HBIT 0x4000             /* Set on hidden avp's */
-
-#define ASYNC_FRAMING 2
-#define SYNC_FRAMING 1
-
-#define ANALOG_BEARER 2
-#define DIGITAL_BEARER 1
-
-#define VENDOR_ERROR 6
-
-#define ERROR_RESERVED 3
-#define ERROR_LENGTH 2
-#define ERROR_NOTEXIST 1
-#define ERROR_NORES 4
-#define ERROR_INVALID 6
-#define RESULT_CLEAR 1
-#define RESULT_ERROR 2
-#define RESULT_EXISTS 3
-extern void encrypt_avp (struct buffer *, _u16, struct tunnel *);
-extern int decrypt_avp (char *, struct tunnel *);
-extern int message_type_avp (struct tunnel *, struct call *, void *, int);
-extern int protocol_version_avp (struct tunnel *, struct call *, void *, int);
-extern int framing_caps_avp (struct tunnel *, struct call *, void *, int);
-extern int bearer_caps_avp (struct tunnel *, struct call *, void *, int);
-extern int firmware_rev_avp (struct tunnel *, struct call *, void *, int);
-extern int hostname_avp (struct tunnel *, struct call *, void *, int);
-extern int vendor_avp (struct tunnel *, struct call *, void *, int);
-extern int assigned_tunnel_avp (struct tunnel *, struct call *, void *, int);
-extern int receive_window_size_avp (struct tunnel *, struct call *, void *,
-                                    int);
-extern int result_code_avp (struct tunnel *, struct call *, void *, int);
-extern int assigned_call_avp (struct tunnel *, struct call *, void *, int);
-extern int call_serno_avp (struct tunnel *, struct call *, void *, int);
-extern int bearer_type_avp (struct tunnel *, struct call *, void *, int);
-extern int call_physchan_avp (struct tunnel *, struct call *, void *, int);
-extern int dialed_number_avp (struct tunnel *, struct call *, void *, int);
-extern int dialing_number_avp (struct tunnel *, struct call *, void *, int);
-extern int sub_address_avp (struct tunnel *, struct call *, void *, int);
-extern int frame_type_avp (struct tunnel *, struct call *, void *, int);
-extern int rx_speed_avp (struct tunnel *, struct call *, void *, int);
-extern int tx_speed_avp (struct tunnel *, struct call *, void *, int);
-extern int packet_delay_avp (struct tunnel *, struct call *, void *, int);
-extern int ignore_avp (struct tunnel *, struct call *, void *, int);
-extern int seq_reqd_avp (struct tunnel *, struct call *, void *, int);
-extern int challenge_avp (struct tunnel *, struct call *, void *, int);
-extern int chalresp_avp (struct tunnel *, struct call *, void *, int);
-extern int rand_vector_avp (struct tunnel *, struct call *, void *, int);
-
-extern int add_challenge_avp (struct buffer *, unsigned char *, int);
-extern int add_avp_rws (struct buffer *, _u16);
-extern int add_tunnelid_avp (struct buffer *, _u16);
-extern int add_vendor_avp (struct buffer *);
-extern int add_hostname_avp (struct buffer *, const char *);
-extern int add_firmware_avp (struct buffer *);
-extern int add_bearer_caps_avp (struct buffer *buf, _u16 caps);
-extern int add_frame_caps_avp (struct buffer *buf, _u16 caps);
-extern int add_protocol_avp (struct buffer *buf);
-extern int add_message_type_avp (struct buffer *buf, _u16 type);
-extern int add_result_code_avp (struct buffer *buf, _u16, _u16, char *, int);
-extern int add_bearer_avp (struct buffer *, int);
-extern int add_frame_avp (struct buffer *, int);
-extern int add_rxspeed_avp (struct buffer *, int);
-extern int add_txspeed_avp (struct buffer *, int);
-extern int add_serno_avp (struct buffer *, unsigned int);
-#ifdef TEST_HIDDEN
-extern int add_callid_avp (struct buffer *, _u16, struct tunnel *);
-#else
-extern int add_callid_avp (struct buffer *, _u16);
-#endif
-extern int add_ppd_avp (struct buffer *, _u16);
-extern int add_seqreqd_avp (struct buffer *);
-extern int add_chalresp_avp (struct buffer *, unsigned char *, int);
-extern int add_randvect_avp (struct buffer *, unsigned char *, int);
-extern int add_minbps_avp (struct buffer *buf, int speed);      /* jz: needed for outgoing call */
-extern int add_maxbps_avp (struct buffer *buf, int speed);      /* jz: needed for outgoing call */
-extern int add_number_avp (struct buffer *buf, char *no);       /* jz: needed for outgoing call */
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/avpsend.c ppp-2.4.4/pppd/plugins/pppol2tp/avpsend.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/avpsend.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/avpsend.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,294 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Attribute Value Pair creating routines
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <netinet/in.h>
-#include "l2tp.h"
-
-struct half_words {
-	_u16 s0;
-	_u16 s1;
-	_u16 s2;
-	_u16 s3;
-} __attribute__ ((packed));
-
-void add_header(struct buffer *buf, _u8 length, _u16 type) {
-	struct avp_hdr *avp = (struct avp_hdr *) (buf->start + buf->len);
-	avp->length = htons (length | MBIT);
-	avp->vendorid = htons (VENDOR_ID);
-	avp->attr = htons (type);
-}
-
-/* 
- * These routines should add avp's to a buffer
- * to be sent
- */
-
-/* FIXME:  If SANITY is on, we should check for buffer overruns */
-
-int add_message_type_avp (struct buffer *buf, _u16 type)
-{
-	struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-	add_header(buf, 0x8, 0);
-	ptr->s0 = htons(type);
-    buf->len += 0x8;
-    return 0;
-}
-
-int add_protocol_avp (struct buffer *buf)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0x8, 0x2);        /* Length and M bit */
-    ptr->s0 = htons (OUR_L2TP_VERSION);
-    buf->len += 0x8;
-    return 0;
-}
-
-int add_frame_caps_avp (struct buffer *buf, _u16 caps)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x3);
-    ptr->s0 = 0;
-    ptr->s1 = htons (caps);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_bearer_caps_avp (struct buffer *buf, _u16 caps)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x4);
-    ptr->s0 = 0;
-    ptr->s1 = htons (caps);
-    buf->len += 0xA;
-    return 0;
-}
-
-/* FIXME: I need to send tie breaker AVP's */
-
-int add_firmware_avp (struct buffer *buf)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0x8, 0x6);
-    ptr->s0 = htons (FIRMWARE_REV);
-    buf->len += 0x8;
-    return 0;
-}
-
-int add_hostname_avp (struct buffer *buf, const char *hostname)
-{
-    size_t namelen = strlen(hostname);
-    if (namelen > MAXAVPSIZE - 6) {
-        namelen = MAXAVPSIZE - 6;
-    }
-    add_header(buf, 0x6 + namelen, 0x7);
-    strncpy ((char *) (buf->start + buf->len + sizeof(struct avp_hdr)),
-	     hostname, namelen);
-    buf->len += 0x6 + namelen;
-    return 0;
-}
-
-int add_vendor_avp (struct buffer *buf)
-{
-    add_header(buf, 0x6 + strlen (VENDOR_NAME), 0x8);
-    strcpy ((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), VENDOR_NAME);
-    buf->len += 0x6 + strlen (VENDOR_NAME);
-    return 0;
-}
-
-int add_tunnelid_avp (struct buffer *buf, _u16 tid)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0x8, 0x9);
-    ptr->s0 = htons (tid);
-    buf->len += 0x8;
-    return 0;
-}
-
-int add_avp_rws (struct buffer *buf, _u16 rws)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0x8, 0xA);
-    ptr->s0 = htons (rws);
-    buf->len += 0x8;
-    return 0;
-}
-
-int add_challenge_avp (struct buffer *buf, unsigned char *c, int len)
-{
-    add_header(buf, (0x6 + len), 0xB);
-    memcpy((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), c, len);
-    buf->len += 0x6 + len;
-    return 0;
-}
-
-int add_chalresp_avp (struct buffer *buf, unsigned char *c, int len)
-{
-    add_header(buf, (0x6 + len), 0xD);
-    memcpy((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), c, len);
-    buf->len += 0x6 + len;
-    return 0;
-}
-
-int add_randvect_avp (struct buffer *buf, unsigned char *c, int len)
-{
-    add_header(buf, (0x6 + len), 0x24);
-    memcpy((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), c, len);
-    buf->len += 0x6 + len;
-    return 0;
-}
-
-int add_result_code_avp (struct buffer *buf, _u16 result, _u16 error,
-                         char *msg, int len)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, (0xA + len), 0x1);
-    ptr->s0 = htons (result);
-    ptr->s1 = htons (error);
-    memcpy ((char *) &ptr->s2, msg, len);
-    buf->len += 0xA + len;
-    return 0;
-}
-
-#ifdef TEST_HIDDEN
-int add_callid_avp (struct buffer *buf, _u16 callid, struct tunnel *t)
-{
-#else
-int add_callid_avp (struct buffer *buf, _u16 callid)
-{
-#endif
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-#ifdef TEST_HIDDEN
-    if (t->hbit)
-        raw++;
-#endif
-    add_header(buf, 0x8, 0xE);
-    ptr->s0 = htons (callid);
-    buf->len += 0x8;
-#ifdef TEST_HIDDEN
-    if (t->hbit)
-        encrypt_avp (buf, 8, t);
-#endif
-    return 0;
-}
-
-int add_serno_avp (struct buffer *buf, unsigned int serno)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0xF);
-    ptr->s0 = htons ((serno >> 16) & 0xFFFF);
-    ptr->s1 = htons (serno & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_bearer_avp (struct buffer *buf, int bearer)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x12);
-    ptr->s0 = htons ((bearer >> 16) & 0xFFFF);
-    ptr->s1 = htons (bearer & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_frame_avp (struct buffer *buf, int frame)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x13);
-    ptr->s0 = htons ((frame >> 16) & 0xFFFF);
-    ptr->s1 = htons (frame & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_txspeed_avp (struct buffer *buf, int speed)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x18);
-    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
-    ptr->s1 = htons (speed & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_rxspeed_avp (struct buffer *buf, int speed)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x26);
-    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
-    ptr->s1 = htons (speed & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_physchan_avp (struct buffer *buf, unsigned int physchan)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x19);
-    ptr->s0 = htons ((physchan >> 16) & 0xFFFF);
-    ptr->s1 = htons (physchan & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-int add_ppd_avp (struct buffer *buf, _u16 ppd)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0x8, 0x14);
-    ptr->s0 = htons (ppd);
-    buf->len += 0x8;
-    return 0;
-}
-
-int add_seqreqd_avp (struct buffer *buf)
-{
-    add_header(buf, 0x6, 0x27);
-    buf->len += 0x6;
-    return 0;
-}
-
-/* jz: options dor the outgoing call */
-
-/* jz: Minimum BPS - 16 */
-int add_minbps_avp (struct buffer *buf, int speed)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x10);
-    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
-    ptr->s1 = htons (speed & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-/* jz: Maximum BPS - 17 */
-int add_maxbps_avp (struct buffer *buf, int speed)
-{
-    struct half_words *ptr = (struct half_words *) (buf->start + buf->len + sizeof(struct avp_hdr));
-    add_header(buf, 0xA, 0x11);
-    ptr->s0 = htons ((speed >> 16) & 0xFFFF);
-    ptr->s1 = htons (speed & 0xFFFF);
-    buf->len += 0xA;
-    return 0;
-}
-
-/* jz: Dialed Number 21 */
-int add_number_avp (struct buffer *buf, char *no)
-{
-    add_header(buf, (0x6 + strlen (no)), 0x15);
-    strncpy ((char *) (buf->start + buf->len + sizeof(struct avp_hdr)), no, strlen (no));
-    buf->len += 0x6 + strlen (no);
-    return 0;
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/call.c ppp-2.4.4/pppd/plugins/pppol2tp/call.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/call.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/call.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,656 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Handle a call as a separate thread
- */
-
-#include <stdio.h>
-#include <fcntl.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/wait.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <signal.h>
-#include <termios.h>
-#include "l2tp.h"
-
-#include "ipsecmast.h"
-
-struct buffer *new_payload (struct sockaddr_in peer)
-{
-    struct buffer *tmp = new_buf (MAX_RECV_SIZE);
-    if (!tmp)
-        return NULL;
-    tmp->peer = peer;
-    tmp->start += sizeof (struct payload_hdr);
-    tmp->len = 0;
-    return tmp;
-}
-
-inline void recycle_payload (struct buffer *buf, struct sockaddr_in peer)
-{
-    buf->start = buf->rstart + sizeof (struct payload_hdr);
-    buf->len = 0;
-    buf->peer = peer;
-}
-
-void add_payload_hdr (struct tunnel *t, struct call *c, struct buffer *buf)
-{
-    struct payload_hdr *p;
-    buf->start -= sizeof (struct payload_hdr);
-    buf->len += sizeof (struct payload_hdr);
-    /* Account for no offset */
-    buf->start += 4;
-    buf->len -= 4;
-    if (!c->fbit && !c->ourfbit)
-    {
-        /* Forget about Ns and Nr fields then */
-        buf->start += 4;
-        buf->len -= 4;
-    }
-    if (!c->lbit)
-    {
-        /* Forget about specifying the length */
-        buf->start += 2;
-        buf->len -= 2;
-    }
-    p = (struct payload_hdr *) buf->start;
-/*	p->ver = htons(c->lbit | c->rbit | c->fbit | c->ourfbit | VER_L2TP); */
-    p->ver = htons (c->lbit | c->fbit | c->ourfbit | VER_L2TP);
-    if (c->lbit)
-    {
-        p->length = htons ((_u16) buf->len);
-    }
-    else
-    {
-        p = (struct payload_hdr *) (((char *) p) - 2);
-    }
-    p->tid = htons (t->tid);
-    p->cid = htons (c->cid);
-    if (c->fbit || c->ourfbit)
-    {
-        p->Ns = htons (c->data_seq_num);
-        p->Nr = htons (c->data_rec_seq_num);
-    }
-    c->data_seq_num++;
-/*	c->rbit=0; */
-}
-
-int call_read_packet (struct buffer *buf, int fd, int convert)
-{
-    unsigned char c;
-    unsigned char escape = 0;
-    unsigned char *p;
-    static unsigned char rbuf[MAX_RECV_SIZE];
-    static int pos = 0;
-    static int max = 0;
-    int res;
-    int errors = 0;
-
-    /* Read a packet, doing async->sync conversion if necessary */
-    p = buf->start;
-    while (1)
-    {
-        if (pos >= max)
-        {
-            max = read(fd, rbuf, sizeof (rbuf));
-            res = max;
-            pos = 0;
-        }
-        else
-        {
-            res = 1;
-        }
-
-        c = rbuf[pos++];
-
-	/* if there was a short read, then see what is about */
-        if (res < 1)
-        {
-            if (res == 0)
-            {
-                /*
-                   * Hmm..  Nothing to read.  It happens
-                 */
-                return 0;
-            }
-            else if ((errno == EIO) || (errno == EINTR) || (errno == EAGAIN))
-            {
-
-                /*
-                   * Oops, we were interrupted!
-                   * Or, we ran out of data too soon
-                   * anyway, we discared whatever it is we
-                   * have
-                 */
-                return 0;
-            }
-            errors++;
-            l2tp_log (LOG_DEBUG, "%s: Error %d (%s)\n", __FUNCTION__, errno,
-                 strerror (errno));
-            if (errors > 10)
-            {
-                l2tp_log (LOG_DEBUG,
-                     "%s: Too many errors.  Declaring call dead.\n",
-                     __FUNCTION__);
-		pos=0;
-		max=0;
-                return -errno;
-            }
-            continue;
-        }
-
-        switch (c)
-        {
-        case PPP_FLAG:
-            if (escape)
-            {
-                l2tp_log (LOG_DEBUG, "%s: got an escaped PPP_FLAG\n",
-                     __FUNCTION__);
-		pos=0;
-		max=0;
-                return -EINVAL;
-            }
-
-            if (convert)
-            {
-	      if (buf->len >= 2) {
-		/* must be the end, drop the FCS */
-		buf->len -= 2;
-	      }
-	      else if (buf->len == 1) {
-		/* Do nothing, just return the single character*/
-	      }
-	      else {
-		/* if the buffer is empty, then we have the beginning
-		 * of a packet, not the end
-		 */
-		break;
-	      }
-	    }
-            else
-            {
-		/* if there is space, then insert the byte */
-                if (buf->len < buf->maxlen)
-                {
-                    *p = c;
-                    p++;
-                    buf->len++;
-                }
-            }
-
-	    /* return what we have now */
-            return buf->len;
-
-        case PPP_ESCAPE:
-            escape = PPP_TRANS;
-            if (convert)
-                break;
-
-	    /* fall through */
-        default:
-            if (convert)
-                c ^= escape;
-            escape = 0;
-            if (buf->len < buf->maxlen)
-            {
-                *p = c;
-                p++;
-                buf->len++;
-                break;
-            }
-            l2tp_log (LOG_WARNING, "%s: read overrun\n", __FUNCTION__);
-	    pos=0;
-	    max=0;
-            return -EINVAL;
-        }
-    }
-
-    /* I should never get here */
-    l2tp_log (LOG_WARNING, "%s: You should not see this message.  If you do, please enter "
-			"a bug report at http://lists.xelerance.com/mailman/listinfo/xl2tpd", __FUNCTION__);
-    return -EINVAL;
-}
-
-void call_close (struct call *c)
-{
-    struct buffer *buf;
-    struct schedule_entry *se, *ose;
-    struct call *tmp, *tmp2;
-    if (!c || !c->container)
-    {
-        l2tp_log (LOG_DEBUG, "%s: called on null call or containerless call\n",
-             __FUNCTION__);
-        return;
-    }
-    if (c == c->container->self)
-    {
-        /*
-         * We're actually closing the
-         * entire tunnel
-         */
-
-        /* First deschedule any remaining packet transmissions
-           for this tunnel.  That means Hello's and any reminaing
-           packets scheduled for transmission.  This is a very
-           nasty little piece of code here. */
-
-        se = events;
-        ose = NULL;
-        while (se)
-        {
-            if ((((struct buffer *) se->data)->tunnel == c->container)
-                || ((struct tunnel *) se->data == c->container))
-            {
-#ifdef DEBUG_CLOSE
-                l2tp_log (LOG_DEBUG, "%s: Descheduling event\n", __FUNCTION__);
-#endif
-                if (ose)
-                {
-                    ose->next = se->next;
-                    if ((struct tunnel *) se->data != c->container)
-                        toss ((struct buffer *) (se->data));
-                    free (se);
-                    se = ose->next;
-                }
-                else
-                {
-                    events = se->next;
-                    if ((struct tunnel *) se->data != c->container)
-                        toss ((struct buffer *) (se->data));
-                    free (se);
-                    se = events;
-                }
-            }
-            else
-            {
-                ose = se;
-                se = se->next;
-            }
-        }
-
-        if (c->closing)
-        {
-            /* Really close this tunnel, as our
-               StopCCN has been ack'd */
-#ifdef DEBUG_CLOSE
-            l2tp_log (LOG_DEBUG, "%s: Actually closing tunnel %d\n", __FUNCTION__,
-                 c->container->ourtid);
-#endif
-            destroy_tunnel (c->container);
-            return;
-        }
-
-        /*
-           * We need to close, but need to provide reliable delivery
-           * of the final StopCCN. We record our state to know when
-           * we have actually received an ACK on our StopCCN
-         */
-        c->closeSs = c->container->control_seq_num;
-        buf = new_outgoing (c->container);
-        add_message_type_avp (buf, StopCCN);
-        if (c->container->hbit)
-        {
-            mk_challenge (c->container->chal_them.vector, VECTOR_SIZE);
-            add_randvect_avp (buf, c->container->chal_them.vector,
-                              VECTOR_SIZE);
-        }
-        add_tunnelid_avp (buf, c->container->ourtid);
-        if (c->result < 0)
-            c->result = RESULT_CLEAR;
-        if (c->error < 0)
-            c->error = 0;
-        add_result_code_avp (buf, c->result, c->error, c->errormsg,
-                             strlen (c->errormsg));
-        add_control_hdr (c->container, c, buf);
-        if (gconfig.packet_dump)
-            do_packet_dump (buf);
-#ifdef DEBUG_CLOSE
-        l2tp_log (LOG_DEBUG, "%s: enqueing close message for tunnel\n",
-             __FUNCTION__);
-#endif
-	control_xmit (buf);
-        /*
-           * We also need to stop all traffic on any calls contained
-           * within us.
-         */
-        tmp = c->container->call_head;
-        while (tmp)
-        {
-            tmp2 = tmp->next;
-            tmp->needclose = 0;
-            tmp->closing = -1;
-            call_close (tmp);
-            tmp = tmp2;
-        }
-        l2tp_log (LOG_INFO,
-             "Connection %d closed to %s, port %d (%s)\n", 
-             c->container->tid,
-             IPADDY (c->container->peer.sin_addr),
-             ntohs (c->container->peer.sin_port), c->errormsg);
-    }
-    else
-    {
-        /*
-           * Just close a call
-         */
-        if (c->zlb_xmit)
-            deschedule (c->zlb_xmit);
-/*		if (c->dethrottle) deschedule(c->dethrottle); */
-        if (c->closing)
-        {
-#ifdef DEBUG_CLOSE
-            l2tp_log (LOG_DEBUG, "%s: Actually closing call %d\n", __FUNCTION__,
-                 c->ourcid);
-#endif
-            destroy_call (c);
-            return;
-        }
-        c->closeSs = c->container->control_seq_num;
-        buf = new_outgoing (c->container);
-        add_message_type_avp (buf, CDN);
-        if (c->container->hbit)
-        {
-            mk_challenge (c->container->chal_them.vector, VECTOR_SIZE);
-            add_randvect_avp (buf, c->container->chal_them.vector,
-                              VECTOR_SIZE);
-        }
-        if (c->result < 0)
-            c->result = RESULT_CLEAR;
-        if (c->error < 0)
-            c->error = 0;
-        add_result_code_avp (buf, c->result, c->error, c->errormsg,
-                             strlen (c->errormsg));
-#ifdef TEST_HIDDEN
-        add_callid_avp (buf, c->ourcid, c->container);
-#else
-        add_callid_avp (buf, c->ourcid);
-#endif
-        add_control_hdr (c->container, c, buf);
-        if (gconfig.packet_dump)
-            do_packet_dump (buf);
-#ifdef DEBUG_CLOSE
-        l2tp_log (LOG_DEBUG, "%s: enqueuing close message for call %d\n",
-             __FUNCTION__, c->ourcid);
-#endif
-	control_xmit (buf);
-        l2tp_log (LOG_INFO, "%s: Call %d to %s disconnected\n", __FUNCTION__,
-             c->ourcid, IPADDY (c->container->peer.sin_addr));
-    }
-    /*
-       * Note that we're in the process of closing now
-     */
-    c->closing = -1;
-}
-
-void destroy_call (struct call *c)
-{
-    /*
-     * Here, we unconditionally destroy a call.
-     */
-
-    struct call *p;
-    struct timeval tv;
-    pid_t pid;
-    /*
-     * Close the tty
-     */
-    if (c->fd > 0)
-        close (c->fd);
-/*	if (c->dethrottle) deschedule(c->dethrottle); */
-    if (c->zlb_xmit)
-        deschedule (c->zlb_xmit);
-
-    /*
-     * Kill off pppd and wait for it to 
-     * return to us.  This should only be called
-     * in rare cases if pppd hasn't already died
-     * voluntarily
-     */
-    pid = c->pppd;
-    if (pid)
-    {
-        /* Set c->pppd to zero to prevent recursion with child_handler */
-        c->pppd = 0;
-	/* There is a bug in some pppd versions where sending a SIGTERM
-	   does not actually seem to kill pppd, and xl2tpd waits indefinately
-	   using waitpid, not accepting any new connections either. Therefor
-	   we now use some more force and send it a SIGKILL instead of SIGTERM.
-	   One confirmed buggy version of pppd is ppp-2.4.2-6.4.RHEL4
-	   See http://bugs.xelerance.com/view.php?id=739
-	*/
-	stop_pppd(0);
-    }
-
-    if (c->container)
-    {
-        p = c->container->call_head;
-        /*
-         * Remove us from the call list, although
-         * we might not actually be there
-         */
-        if (p)
-        {
-            if (p == c)
-            {
-                c->container->call_head = c->next;
-                c->container->count--;
-            }
-            else
-            {
-                while (p->next && (p->next != c))
-                    p = p->next;
-                if (p->next)
-                {
-                    p->next = c->next;
-                    c->container->count--;
-                }
-            }
-        }
-    }
-    if (c->lac) {
-        c->lac->c = NULL;
-    }
-
-    free (c);
-
-}
-
-
-struct call *new_call (struct tunnel *parent)
-{
-    unsigned char entropy_buf[2] = "\0";
-    struct call *tmp = zalloc (sizeof (struct call));
-
-    if (!tmp)
-        return NULL;
-    tmp->tx_pkts = 0;
-    tmp->rx_pkts = 0;
-    tmp->tx_bytes = 0;
-    tmp->rx_bytes = 0;
-    tmp->zlb_xmit = NULL;
-/*	tmp->throttle = 0; */
-/*	tmp->dethrottle=NULL; */
-    tmp->prx = 0;
-/*	tmp->rbit = 0; */
-    tmp->msgtype = 0;
-/*	tmp->timeout = 0; */
-    tmp->data_seq_num = 0;
-    tmp->data_rec_seq_num = 0;
-    tmp->pLr = -1;
-    tmp->nego = 0;
-    tmp->debug = 0;
-    tmp->seq_reqd = 0;
-    tmp->state = 0;             /* Nothing so far */
-    if (parent->self)
-    {
-#ifndef TESTING
-/*	while(get_call(parent->ourtid, (tmp->ourcid = (rand() && 0xFFFF)),0,0)); */
-            /* FIXME: What about possibility of multiple random #'s??? */
-            /* tmp->ourcid = (rand () & 0xFFFF); */
-            get_entropy(entropy_buf, 2);
-        {
-            unsigned short *temp;
-            temp = (unsigned short *)entropy_buf;
-            tmp->ourcid = *temp & 0xFFFF;
-#ifdef DEBUG_ENTROPY
-            l2tp_log(LOG_DEBUG, "ourcid = %u, entropy_buf = %hx\n", tmp->ourcid, *temp);
-#endif
-        }
-#else
-        tmp->ourcid = 0x6227;
-#endif
-    }
-    tmp->dialed[0] = 0;
-    tmp->dialing[0] = 0;
-    tmp->subaddy[0] = 0;
-    tmp->physchan = -1;
-    tmp->serno = 0;
-    tmp->bearer = -1;
-    tmp->cid = -1;
-    tmp->qcid = -1;
-    tmp->container = parent;
-/*	tmp->rws = -1; */
-    tmp->fd = -1;
-    tmp->pnu = 0;
-    tmp->cnu = 0;
-    tmp->needclose = 0;
-    tmp->closing = 0;
-    tmp->die = 0;
-    tmp->pppd = 0;
-    tmp->error = -1;
-    tmp->result = -1;
-    tmp->errormsg[0] = 0;
-    tmp->fbit = 0;
-    tmp->cid = 0;
-    tmp->lbit = 0;
-    /* Inherit LAC and LNS from parent */
-    tmp->lac = parent->lac;
-    tmp->addr = 0;
-/*	tmp->ourrws = DEFAULT_RWS_SIZE;	 */
-/*	if (tmp->ourrws >= 0)
-		tmp->ourfbit = FBIT;
-	else */
-    tmp->ourfbit = 0;           /* initialize to 0 since we don't actually use this 
-                                   value at this point anywhere in the code (I don't 
-                                   think)  We might just be able to remove it completely */
-	return tmp;
-}
-
-struct call *get_tunnel (int tunnel, unsigned int addr, int port)
-{
-    struct tunnel *st;
-    if (tunnel)
-    {
-        st = tunnels.head;
-        while (st)
-        {
-            if (st->ourtid == tunnel)
-            {
-                return st->self;
-            }
-            st = st->next;
-        }
-    }
-    return NULL;
-}
-
-struct call *get_call (int tunnel, int call, unsigned int addr, int port,
-		       IPsecSAref_t refme, IPsecSAref_t refhim)
-{
-    /*
-     * Figure out which call struct should handle this. 
-     * If we have tunnel and call ID's then they are unique.
-     * Otherwise, if the tunnel is 0, look for an existing connection
-     * or create a new tunnel.
-     */
-    struct tunnel *st;
-    struct call *sc;
-    if (tunnel)
-    {
-        st = tunnels.head;
-        while (st)
-        {
-	    if (st->ourtid == tunnel &&
-		(gconfig.ipsecsaref==0 ||
-		 (st->refhim == refhim
-		  || refhim==IPSEC_SAREF_NULL
-		  || st->refhim==IPSEC_SAREF_NULL)))
-            {
-                if (call)
-                {
-                    sc = st->call_head;
-                    while (sc)
-                    {
-			/* confirm that this is in fact a call with the right SA! */
-			if (sc->ourcid == call) return sc;
-                        sc = sc->next;
-                    }
-                    /* l2tp_log (LOG_DEBUG, "%s: can't find call %d in tunnel %d\n (ref=%d/%d)",
-			      __FUNCTION__, call, tunnel, refme, refhim); */
-                    return NULL;
-                }
-                else
-                {
-                    return st->self;
-                }
-            }
-            st = st->next;
-        }
-
-        /* l2tp_log (LOG_INFO, "Can not find tunnel %u (refhim=%u)\n",
-		  tunnel, refhim); */
-        return NULL;
-    }
-    else
-    {
-        /* You can't specify a call number if you haven't specified
-           a tunnel silly! */
-
-        if (call)
-        {
-            l2tp_log (LOG_WARNING,
-                 "%s: call ID specified, but no tunnel ID specified.  tossing.\n",
-                 __FUNCTION__);
-            return NULL;
-        }
-        /*
-         * Well, nothing appropriate...  Let's add a new tunnel, if
-         * we are not at capacity.
-         */
-        if (gconfig.debug_tunnel)
-        {
-            l2tp_log (LOG_DEBUG,
-                 "%s: allocating new tunnel for host %s, port %d.\n",
-                 __FUNCTION__, IPADDY (addr), ntohs (port));
-        }
-        if (!(st = new_tunnel ()))
-        {
-            l2tp_log (LOG_WARNING,
-                 "%s: unable to allocate new tunnel for host %s, port %d.\n",
-                 __FUNCTION__, IPADDY (addr), ntohs (port));
-            return NULL;
-        };
-        st->peer.sin_family = AF_INET;
-        st->peer.sin_port = port;
-	st->refme  = refme;
-	st->refhim = refhim;
-        bcopy (&addr, &st->peer.sin_addr, sizeof (addr));
-        st->next = tunnels.head;
-        tunnels.head = st;
-        tunnels.count++;
-        return st->self;
-    }
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/call.h ppp-2.4.4/pppd/plugins/pppol2tp/call.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/call.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/call.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,105 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Handle a call as a separate thread (header file)
- */
-#include <sys/time.h>
-#include "misc.h"
-#include "common.h"
-#include "ipsecmast.h"
-
-#define CALL_CACHE_SIZE 256
-
-struct call
-{
-/*	int rbit;		Set the "R" bit on the next packet? */
-    int lbit;                   /* Should we send length field? */
-/*	int throttle;	Throttle the connection? */
-    int seq_reqd;               /* Sequencing required? */
-    int tx_pkts;                /* Transmitted packets */
-    int rx_pkts;                /* Received packets */
-    int tx_bytes;               /* transmitted bytes */
-    int rx_bytes;               /* received bytes */
-    struct schedule_entry *zlb_xmit;
-    /* Scheduled ZLB transmission */
-/*	struct schedule_entry *dethrottle; */
-    /* Scheduled dethrottling (overrun) */
-/*	int timeout;	Has our timeout expired? If so, we'll go ahead
-					 and transmit, full window or not, and set the
-					 R-bit on this packet.  */
-    int prx;                    /* What was the last packet we sent
-                                   as an Nr? Used to manage payload ZLB's */
-    int state;                  /* Current state */
-    int frame;                  /* Framing being used */
-    struct call *next;          /* Next call, for linking */
-    int fd;
-    int debug;
-    int msgtype;                /* What kind of message are we
-                                   working with right now? */
-
-    int ourcid;                 /* Our call number */
-    int cid;                    /* Their call number */
-    int qcid;                   /* Quitting CID */
-    int bearer;                 /* Bearer type of call */
-    unsigned int serno;         /* Call serial number */
-    unsigned int addr;          /* Address reserved for this call */
-    int txspeed;                /* Transmit speed */
-    int rxspeed;                /* Receive speed */
-    int ppd;                    /* Packet processing delay (of peer) */
-    int physchan;               /* Physical channel ID */
-    char dialed[MAXSTRLEN];     /* Number dialed for call */
-    char dialing[MAXSTRLEN];    /* Original caller ID */
-    char subaddy[MAXSTRLEN];    /* Sub address */
-
-    int needclose;              /* Do we need to close this call? */
-    int closing;                /* Are we actually in the process of closing? */
-    /*
-       needclose            closing         state
-       =========            =======         =====
-       0                       0            Running
-       1                       0            Send Closing notice
-       1                       1            Waiting for closing notice
-       0                       1            Closing ZLB received, actulaly close
-     */
-    struct tunnel *container;   /* Tunnel we belong to */
-     int pppd;
-    int die;
-    int nego;                   /* Show negotiation? */
-    int result;                 /* Result code */
-    int error;                  /* Error code */
-    int fbit;                   /* Use sequence numbers? */
-    int ourfbit;                /* Do we want sequence numbers? */
-/*	int ourrws;		Our RWS for the call */
-    int cnu;                    /* Do we need to send updated Ns, Nr values? */
-    int pnu;                    /* ditto for payload packet */
-    char errormsg[MAXSTRLEN];   /* Error message */
-/*	int rws;		Receive window size, or -1 for none */
-    struct timeval lastsent;    /* When did we last send something? */
-    _u16 data_seq_num;          /* Sequence for next payload packet */
-    _u16 data_rec_seq_num;      /* Sequence for next received payload packet */
-    _u16 closeSs;               /* What number was in Ns when we started to 
-                                   close? */
-    int pLr;                    /* Last packet received by peer */
-    struct lac *lac;            /* LAC that owns us */
-};
-
-
-extern void push_handler (int);
-extern void toss (struct buffer *);
-extern struct call *get_call (int tunnel, int call, unsigned int addr,
-			      int port,
-			      IPsecSAref_t refme, IPsecSAref_t refhim);
-extern struct call *get_tunnel (int, unsigned int, int);
-extern void destroy_call (struct call *);
-extern struct call *new_call (struct tunnel *);
-extern void set_error (struct call *, int, const char *, ...);
-void *call_thread_init (void *);
-void call_close (struct call *);
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/common.h ppp-2.4.4/pppd/plugins/pppol2tp/common.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/common.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/common.h	2013-01-17 16:41:29.111156521 +0400
@@ -1,17 +1,154 @@
-/*
- * Layer 2 Tunnelling Protocol Daemon
- * Copyright (C) 2002 Jeff McAdams
- *
- * This software is distributed under the terms of the GPL, which you
- * should have receivede along with this source.
- *
- * Defines common to several different files
- */
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <memory.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <netdb.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <net/if.h>
+#include <linux/if_ether.h>
+#include <linux/if_pppox.h>
+#include <linux/if_pppol2tp.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <pppd.h>
+
+
+typedef union {
+	int8_t  *p8;
+	int16_t *p16;
+	int32_t *p32;
+	uint8_t *pu8;
+	uint16_t *pu16;
+	uint32_t *pu32;
+} COMMON_POINTER, *PCOMMON_POINTER;
+
+typedef struct {
+	int ifd;
+	struct in_addr addr;
+	uint32_t tid;
+	uint32_t sid;
+	uint32_t remtid;
+	uint32_t remsid;
+} SHT, *PSHT;
+
+
+#define L2TP_MADDR_LEN	128
+#define L2TP_MHOST_LEN	128
+#define L2TP_PORT			1701
+#define L2TP_VERSION		2
+#define L2TP_MAVP_LEN	1024
+#define L2TP_AVP_HLEN	6
+#define L2TP_HLEN			12
+#define L2TP_READ_NBUF	4096
+#define L2TP_MTRY_COUNT	3
+
+#define L2TP_TBIT		(1 << 15)
+#define L2TP_LBIT		(1 << 14)
+#define L2TP_SBIT		(1 << 11)
+#define L2TP_OBIT		(1 << 9)
+#define L2TP_PBIT		(1 << 8)
+
+#define L2TP_AVP_MBIT	(1 << 15)
+#define L2TP_AVP_HBIT	(1 << 14)
+
+#define close_socket(s) shutdown(s, SHUT_RDWR); close(s)
+
+typedef struct {
+	uint16_t tid;
+	uint16_t sid;
+	uint16_t ns;
+	uint16_t nr;
+	uint16_t remtid;
+	uint16_t remsid;
+	uint16_t remns;
+	uint16_t remnr;
+	struct in_addr addr;
+	char chostname[L2TP_MHOST_LEN];
+	int isock;
+	int istage;
+	int ilast_try;
+	uint16_t acksid;
+	pid_t parent_pid;
+	
+} L2TP_STATE, *PL2TP_STATE;
+
+typedef struct __st_l2tp_avp {
+	struct __st_l2tp_avp *pnext;
+	uint8_t umand;
+	uint8_t uhidden;
+	uint16_t ulen;
+	uint16_t uvendor;
+	uint16_t utype;
+	uint8_t udata[L2TP_MAVP_LEN];
+} L2TP_AVP, *PL2TP_AVP;
+
+typedef enum {
+	AVP_ATTR_MESSAGE_TYPE = 0,
+	AVP_ATTR_RESULT_CODE	= 1,
+	AVP_ATTR_PROTO_VERSION = 2,
+	AVP_ATTR_FRAME_CAP = 3,
+	AVP_ATTR_BEARER_CAP = 4,
+	AVP_ATTR_FIRM_REV = 6,
+	AVP_ATTR_HOST_NAME = 7,
+	AVP_ATTR_VEN_NAME = 8,
+	AVP_ATTR_ASSIGN_TUN = 9,
+	AVP_ATTR_REC_WIN_SIZE = 10,
+	AVP_ATTR_CAUSE_CODE = 12,
+	AVP_ATTR_ASSIGN_SES = 14,
+	AVP_ATTR_SERNUM = 15,
+	AVP_ATTR_BEARER_TYPE = 18,
+	AVP_ATTR_FRAME_TYPE = 19,
+	AVP_ATTR_CALLED_NUM = 21,
+	AVP_ATTR_CALLING_NUM = 22,
+	AVP_ATTR_TXSPEED = 24,
+	AVP_ATTR_PHYS_CHAN_ID = 25,
+	AVP_ATTR_CALL_ERR = 34,
+	AVP_ATTR_RXSPEED = 38,
+	AVP_ATTR_SEQ_REQ = 39
+} AVP_ATTR;
+
+typedef enum {
+	AVP_MT_SCCRQ = 1,
+	AVP_MT_SCCRP = 2,
+	AVP_MT_SCCCN = 3,
+	AVP_MT_STOPCCN = 4,
+	AVP_MT_HELLO = 6,
+	AVP_MT_OCRQ = 7,
+	AVP_MT_OCRP = 8,
+	AVP_MT_OCCN = 9,
+	AVP_MT_ICRQ = 10,
+	AVP_MT_ICRP = 11,
+	AVP_MT_ICCN = 12,
+	AVP_MT_CDN = 14,
+	AVP_MT_WEN = 15,
+	AVP_MT_SLI = 16
+} AVP_MESSAGE_TYPE;
+
+/* avp proc start */
+int l2tp_avp_parse(PL2TP_STATE pstate, const uint8_t *pdata, uint32_t upktlen, PL2TP_AVP *ppres);
+int l2tp_avp_build_pkt(PL2TP_STATE pstate, uint8_t **ppdata, PL2TP_AVP pavp);
+void l2tp_avp_free_pkt(uint8_t **ppdata);
+PL2TP_AVP l2tp_avp_find(PL2TP_AVP phead, uint16_t utype);
+PL2TP_AVP l2tp_avp_add(PL2TP_AVP ptail, uint16_t utype, uint8_t *pdata, uint32_t ulen);
+void l2tp_avp_free_list(PL2TP_AVP pavp_head);
+
+int l2tp_avp_build_req(PL2TP_STATE pstate, uint16_t utype, uint8_t **ppdata);
+int l2tp_avp_parse_res(PL2TP_STATE pstate, uint16_t utype, const uint8_t *pdata, uint32_t ulen);
+
+/* avp proc end */
+
+int l2tp_control_init(const char *pppol2tp_lns);
+int l2tp_control_get_socket();
+int l2tp_control_exit();
 
-#ifndef _COMMON_H_
-typedef unsigned char _u8;
-typedef unsigned short _u16;
-typedef unsigned long long _u64;
-extern int rand_source;
-#define _COMMON_H_
 #endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/control.c ppp-2.4.4/pppd/plugins/pppol2tp/control.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/control.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/control.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,1325 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Control Packet Handling
- *
- */
-
-#include <errno.h>
-#include <string.h>
-#include <stdio.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include "l2tp.h"
-
-_u16 ppp_crc16_table[256] = {
-    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
-    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
-    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
-    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
-    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
-    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
-    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
-    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
-    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
-    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
-    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
-    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
-    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
-    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
-    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
-    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
-    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
-    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
-    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
-    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
-    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
-    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
-    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
-    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
-    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
-    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
-    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
-    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
-    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
-    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
-    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
-    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
-};
-
-int global_serno = 1;
-
-struct buffer *new_outgoing (struct tunnel *t)
-{
-    /*
-     * Make a new outgoing control packet
-     */
-    struct buffer *tmp = new_buf (MAX_RECV_SIZE);
-    if (!tmp)
-        return NULL;
-    tmp->peer = t->peer;
-    tmp->start += sizeof (struct control_hdr);
-    tmp->len = 0;
-    tmp->retries = 0;
-    tmp->tunnel = t;
-    return tmp;
-}
-
-inline void recycle_outgoing (struct buffer *buf, struct sockaddr_in peer)
-{
-    /* 
-     * This should only be used for ZLB's!
-     */
-    buf->start = buf->rstart + sizeof (struct control_hdr);
-    buf->peer = peer;
-    buf->len = 0;
-    buf->retries = -1;
-    buf->tunnel = NULL;
-}
-void add_fcs (struct buffer *buf)
-{
-    _u16 fcs = PPP_INITFCS;
-    unsigned char *c = buf->start;
-    int x;
-    for (x = 0; x < buf->len; x++)
-    {
-        fcs = PPP_FCS (fcs, *c);
-        c++;
-    }
-    fcs = fcs ^ 0xFFFF;
-    *c = fcs & 0xFF;
-    c++;
-    *c = (fcs >> 8) & 0xFF;
-    buf->len += 2;
-}
-
-void add_control_hdr (struct tunnel *t, struct call *c, struct buffer *buf)
-{
-    struct control_hdr *h;
-    buf->start -= sizeof (struct control_hdr);
-    buf->len += sizeof (struct control_hdr);
-    h = (struct control_hdr *) buf->start;
-    h->ver = htons (TBIT | LBIT | FBIT | VER_L2TP);
-    h->length = htons ((_u16) buf->len);
-    h->tid = htons (t->tid);
-    h->cid = htons (c->cid);
-    h->Ns = htons (t->control_seq_num);
-    h->Nr = htons (t->control_rec_seq_num);
-    t->control_seq_num++;
-
-}
-
-void hello (void *tun)
-{
-    struct buffer *buf;
-    struct tunnel *t;
-    struct timeval tv;
-    tv.tv_sec = HELLO_DELAY;
-    tv.tv_usec = 0;
-    t = (struct tunnel *) tun;
-    buf = new_outgoing (t);
-    add_message_type_avp (buf, Hello);
-    add_control_hdr (t, t->self, buf);
-    if (gconfig.packet_dump)
-        do_packet_dump (buf);
-#ifdef DEBUG_HELLO
-    l2tp_log (LOG_DEBUG, "%s: sending Hello on %d\n", __FUNCTION__, t->ourtid);
-#endif
-    control_xmit (buf);
-    
-    /*
-     * Schedule another Hello in a little bit.
-     */
-#ifdef DEBUG_HELLO
-    l2tp_log (LOG_DEBUG, "%s: scheduling another Hello on %d\n", __FUNCTION__,
-         t->ourtid);
-#endif
-    t->hello = schedule (tv, hello, (void *) t);
-}
-
-void control_zlb (struct buffer *buf, struct tunnel *t, struct call *c)
-{
-    recycle_outgoing (buf, t->peer);
-    add_control_hdr (t, c, buf);
-    t->control_seq_num--;
-#ifdef DEBUG_ZLB
-    l2tp_log (LOG_DEBUG, "%s: sending control ZLB on tunnel %d\n", __FUNCTION__,
-         t->tid);
-#endif
-    udp_xmit (buf, t);
-}
-
-int control_finish (struct tunnel *t, struct call *c)
-{
-    /*
-     * After all AVP's have been handled, do anything else
-     * which needs to be done, like prepare response
-     * packets to go back.  This is essentially the
-     * implementation of the state machine of section 7.2.1
-     *
-     * If we set c->needclose, the call (or tunnel) will
-     * be closed upon return.
-     */
-    struct buffer *buf;
-    struct call *p;
-    struct timeval tv;
-    int tmptid,tmpcid;
-
-    if (c->msgtype < 0)
-    {
-        l2tp_log (LOG_DEBUG, "%s: Whoa...  non-ZLB with no message type!\n",
-             __FUNCTION__);
-        return -EINVAL;
-    }
-    if (gconfig.debug_state)
-        l2tp_log (LOG_DEBUG,
-             "%s: message type is %s(%d).  Tunnel is %d, call is %d.\n",
-             __FUNCTION__, msgtypes[c->msgtype], c->msgtype, t->tid, c->cid);
-    switch (c->msgtype)
-    {
-    case 0:
-        /*
-         * We need to initiate a connection.
-         */
-        if (t->self == c)
-        {
-            if (t->lac)
-            {
-                t->ourrws = t->lac->tun_rws;
-                t->hbit = t->lac->hbit;
-            }
-            /* This is an attempt to bring up the tunnel */
-            t->state = SCCRQ;
-            buf = new_outgoing (t);
-            add_message_type_avp (buf, SCCRQ);
-            if (t->hbit)
-            {
-                mk_challenge (t->chal_them.vector, VECTOR_SIZE);
-                add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
-            }
-            add_protocol_avp (buf);
-            add_frame_caps_avp (buf, t->ourfc);
-            add_bearer_caps_avp (buf, t->ourbc);
-            /* FIXME:  Tie breaker */
-            add_firmware_avp (buf);
-            if (t->lac && t->lac->hostname && t->lac->hostname[0])
-                add_hostname_avp (buf, t->lac->hostname);
-            else
-                add_hostname_avp (buf, hostname);
-            add_vendor_avp (buf);
-            add_tunnelid_avp (buf, t->ourtid);
-            if (t->ourrws >= 0)
-                add_avp_rws (buf, t->ourrws);
-            if ((t->lac && t->lac->challenge))
-            {
-		if (t->chal_them.challenge)
-		    free(t->chal_them.challenge);
-                t->chal_them.challenge = zalloc(MD_SIG_SIZE);
-                if (!(t->chal_them.challenge))
-                {
-                    l2tp_log (LOG_WARNING, "%s: zalloc failed for challenge\n",
-			 __FUNCTION__);
-		    toss (buf);
-                    return -EINVAL;
-                }
-                mk_challenge (t->chal_them.challenge, MD_SIG_SIZE);
-                t->chal_them.chal_len = MD_SIG_SIZE;
-                add_challenge_avp (buf, t->chal_them.challenge,
-				   t->chal_them.chal_len);
-                t->chal_them.state = STATE_CHALLENGED;
-                /* We generate the challenge and make a note that we plan to
-                   challenge the peer, but we can't predict the response yet
-                   because we don't know their hostname AVP */
-            }
-            add_control_hdr (t, c, buf);
-            c->cnu = 0;
-            if (gconfig.packet_dump)
-                do_packet_dump (buf);
-            if (gconfig.debug_state)
-                l2tp_log (LOG_DEBUG, "%s: sending SCCRQ\n",
-                     __FUNCTION__);
-            control_xmit (buf);
-        }
-        else
-        {
-                c->state = ICRQ;
-                if (c->lac)
-                {
-                    c->lbit = c->lac->lbit ? LBIT : 0;
-/*					c->ourrws = c->lac->call_rws;
-					if (c->ourrws > -1) c->ourfbit = FBIT; else c->ourfbit = 0; */
-                }
-                buf = new_outgoing (t);
-                add_message_type_avp (buf, ICRQ);
-                if (t->hbit)
-                {
-                    mk_challenge (t->chal_them.vector, VECTOR_SIZE);
-                    add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
-                }
-#ifdef TEST_HIDDEN
-                add_callid_avp (buf, c->ourcid, t);
-#else
-                add_callid_avp (buf, c->ourcid);
-#endif
-                add_serno_avp (buf, global_serno);
-                c->serno = global_serno;
-                global_serno++;
-                add_bearer_avp (buf, 0);
-                add_control_hdr (t, c, buf);
-                c->cnu = 0;
-                if (gconfig.packet_dump)
-                    do_packet_dump (buf);
-                if (gconfig.debug_state)
-                    l2tp_log (LOG_DEBUG, "%s: sending ICRQ\n", __FUNCTION__);
-		control_xmit (buf);
-        }
-        break;
-    case SCCRP:
-        /*
-         * We have a reply.  If everything is okay, send
-         * a connected message
-         */
-        if (t->fc < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer did not specify framing capability.  Closing.\n",
-                     __FUNCTION__);
-            set_error (c, VENDOR_ERROR, "Specify framing capability");
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        /* FIXME: Do we need to be sure they specified a version number?
-         *   Theoretically, yes, but we don't have anything in the code
-         *   to actually *do* anything with it, so...why check at this point?
-         * We shouldn't be requiring a bearer capabilities avp to be present in 
-         * SCCRQ and SCCRP as they aren't required
-         if (t->bc < 0 ) {
-         if (DEBUG) log(LOG_DEBUG,
-         "%s: Peer did not specify bearer capability.  Closing.\n",__FUNCTION__);
-         set_error(c, VENDOR_ERROR, "Specify bearer capability");
-         c->needclose = -1;
-         return -EINVAL;
-         } */
-        if ((!strlen (t->hostname)) && ((t->chal_them.state) || ((t->chal_us.state))))
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer did not specify hostname.  Closing.\n",
-                     __FUNCTION__);
-            set_error (c, VENDOR_ERROR, "Specify your hostname");
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        if (t->tid <= 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer did not specify assigned tunnel ID.  Closing.\n",
-                     __FUNCTION__);
-            set_error (c, VENDOR_ERROR, "Specify your assigned tunnel ID");
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        if (t->chal_them.state)
-        {
-            t->chal_them.ss = SCCRP;
-            if (handle_challenge (t, &t->chal_them))
-            {
-                set_error (c, VENDOR_ERROR, "No secret key on our side");
-                l2tp_log (LOG_WARNING, "%s: No secret key for authenticating '%s'\n",
-                     __FUNCTION__, t->hostname);
-                c->needclose = -1;
-                return -EINVAL;
-            }
-            if (memcmp
-                (t->chal_them.reply, t->chal_them.response, MD_SIG_SIZE))
-            {
-                set_error (c, VENDOR_ERROR,
-                           "Invalid challenge authentication");
-                l2tp_log (LOG_DEBUG, "%s: Invalid authentication for host '%s'\n",
-                     __FUNCTION__, t->hostname);
-                c->needclose = -1;
-                return -EINVAL;
-            }
-        }
-        if (t->chal_us.state)
-        {
-            t->chal_us.ss = SCCCN;
-            if (handle_challenge (t, &t->chal_us))
-            {
-                l2tp_log (LOG_WARNING, "%s: No secret for authenticating to '%s'\n",
-                     __FUNCTION__, t->hostname);
-                set_error (c, VENDOR_ERROR, "No secret key on our end");
-                c->needclose = -1;
-                return -EINVAL;
-            };
-        }
-        t->state = SCCCN;
-        buf = new_outgoing (t);
-        add_message_type_avp (buf, SCCCN);
-        if (t->hbit)
-        {
-            mk_challenge (t->chal_them.vector, VECTOR_SIZE);
-            add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
-        }
-        if (t->chal_us.state)
-            add_chalresp_avp (buf, t->chal_us.response, MD_SIG_SIZE);
-        add_control_hdr (t, c, buf);
-        if (gconfig.packet_dump)
-            do_packet_dump (buf);
-        c->cnu = 0;
-        if (gconfig.debug_state)
-            l2tp_log (LOG_DEBUG, "%s: sending SCCCN\n", __FUNCTION__);
-	control_xmit (buf);
-        /* Schedule a HELLO */
-        tv.tv_sec = HELLO_DELAY;
-        tv.tv_usec = 0;
-#ifdef DEBUG_HELLO
-        l2tp_log (LOG_DEBUG, "%s: scheduling initial HELLO on %d\n", __FUNCTION__,
-             t->ourtid);
-#endif
-        t->hello = schedule (tv, hello, (void *) t);
-        l2tp_log (LOG_NOTICE,
-		  "Connection established to %s, %d.  Local: %d, Remote: %d (ref=%u/%u).\n",
-		  IPADDY (t->peer.sin_addr),
-		  ntohs (t->peer.sin_port), t->ourtid, t->tid, t->refme, t->refhim);
-        if (t->lac)
-        {
-            /* This is part of a LAC, so we want to go ahead
-               and start an ICRQ now */
-            magic_lac_dial (t->lac);
-        }
-        break;
-    case StopCCN:
-        if (t->qtid < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer tried to disconnect without specifying tunnel ID\n",
-                     __FUNCTION__);
-            return -EINVAL;
-        }
-
-       /* Work around bug in MSL2TP client */
-        if ((t->firmware == 0xff00) && (!(strncmp(t->vendor, "Deterministic Networks Inc.", 27))))
-            tmptid = t->ourtid;
-        else
-            tmptid = t->tid;
-        if ((t->qtid != tmptid) && (tmptid > 0))
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer [Vendor:%s] [Firmware:%d (0x%.4x)] tried to disconnect with invalid TID (%d != %d)\n",
-                     __FUNCTION__, t->vendor, t->firmware, t->firmware, t->qtid, tmptid);
-            return -EINVAL;
-        }
-        /* In case they're disconnecting immediately after SCCN */
-        if (!t->tid)
-            t->tid = t->qtid;
-        if (t->self->result < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer tried to disconnect without specifying result code.\n",
-                     __FUNCTION__);
-            return -EINVAL;
-        }
-        l2tp_log (LOG_INFO,
-             "%s: Connection closed to %s, port %d (%s), Local: %d, Remote: %d\n",
-             __FUNCTION__, IPADDY (t->peer.sin_addr),
-             ntohs (t->peer.sin_port), t->self->errormsg, t->ourtid, t->tid);
-        
-        c->needclose = 0;
-        c->closing = -1;
-        stop_pppd(0);
-        
-        break;
-    case ICRP:
-        if (c->cid < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer tried to negotiate ICRP without specifying call ID\n",
-                     __FUNCTION__);
-            c->needclose = -1;
-            return -EINVAL;
-        }
-        c->state = ICCN;
-        if (t->fc & SYNC_FRAMING)
-            c->frame = SYNC_FRAMING;
-        else
-            c->frame = ASYNC_FRAMING;
-
-        buf = new_outgoing (t);
-        add_message_type_avp (buf, ICCN);
-        if (t->hbit)
-        {
-            mk_challenge (t->chal_them.vector, VECTOR_SIZE);
-            add_randvect_avp (buf, t->chal_them.vector, VECTOR_SIZE);
-        }
-        add_txspeed_avp (buf, DEFAULT_TX_BPS);
-        add_frame_avp (buf, c->frame);
-/*		if (c->ourrws >= 0)
-			add_avp_rws(buf, c->ourrws); */
-        /* FIXME: Packet Processing Delay */
-        /* We don't need any kind of proxy PPP stuff */
-        /* Can we proxy authenticate ourselves??? */
-        add_rxspeed_avp (buf, DEFAULT_RX_BPS);
-/* add_seqreqd_avp (buf); *//* We don't have sequencing code, so
- * don't ask for sequencing */
-        add_control_hdr (t, c, buf);
-        if (gconfig.packet_dump)
-            do_packet_dump (buf);
-        c->cnu = 0;
-        if (gconfig.debug_state)
-            l2tp_log (LOG_DEBUG, "%s: Sending ICCN\n", __FUNCTION__);
-        l2tp_log (LOG_NOTICE,
-		  "Call established with %s, Local: %d, Remote: %d, Serial: %d (ref=%u/%u)\n",
-		  IPADDY (t->peer.sin_addr), c->ourcid, c->cid,
-		  c->serno, t->refme, t->refhim);
-	control_xmit (buf);
-
-        start_pppd (c);
-        break;
-    case CDN:
-        if (c->qcid < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer tried to disconnect without specifying call ID\n",
-                     __FUNCTION__);
-            return -EINVAL;
-        }
-        if (c == t->self)
-        {
-            p = t->call_head;
-            while (p && (p->cid != c->qcid))
-                p = p->next;
-            if (!p)
-            {
-                if (DEBUG)
-                    l2tp_log (LOG_DEBUG,
-                         "%s: Unable to determine call to be disconnected.\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-        }
-        else {
-            p = c;
-	}
-
-       /* Work around bug in MSL2TP client */
-        if ((t->firmware == 0xff00) && (!(strncmp(t->vendor, "Deterministic Networks Inc.", 27))))
-            tmpcid = p->ourcid;
-        else
-            tmpcid = p->cid;
-
-        if ((c->qcid != tmpcid) && tmpcid > 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer tried to disconnect with invalid CID (%d != %d)\n",
-                     __FUNCTION__, c->qcid, c->ourcid);
-            return -EINVAL;
-        }
-        c->qcid = -1;
-        if (c->result < 0)
-        {
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Peer tried to disconnect without specifying result code.\n",
-                     __FUNCTION__);
-            return -EINVAL;
-        }
-        l2tp_log (LOG_INFO,
-             "%s: Connection closed to %s, serial %d (%s)\n", __FUNCTION__,
-             IPADDY (t->peer.sin_addr), c->serno, c->errormsg);
-        c->needclose = 0;
-        c->closing = -1;
-        
-        stop_pppd(0);
-        
-        break;
-    case Hello:
-        break;
-    case SLI:
-        break;
-    default:
-	if(DEBUG)
-    	    l2tp_log (LOG_DEBUG,
-             "%s: Don't know how to finish a message of type %d\n",
-             __FUNCTION__, c->msgtype);
-        set_error (c, VENDOR_ERROR, "Unimplemented message %d\n", c->msgtype);
-    }
-    return 0;
-}
-
-inline int check_control (const struct buffer *buf, struct tunnel *t,
-                          struct call *c)
-{
-    /*
-     * Check if this is a valid control
-     * or not.  Returns 0 on success
-     */
-    struct control_hdr *h = (struct control_hdr *) (buf->start);
-    struct buffer *zlb;
-    if (buf->len < sizeof (struct control_hdr))
-    {
-        if (DEBUG)
-        {
-            l2tp_log (LOG_DEBUG,
-                 "%s: Received too small of packet\n", __FUNCTION__);
-        }
-        return -EINVAL;
-    }
-#ifdef SANITY
-    if (buf->len != h->length)
-    {
-        if (DEBUG)
-        {
-            l2tp_log (LOG_DEBUG,
-                 "%s: Reported and actual sizes differ (%d != %d)\n",
-                 __FUNCTION__, h->length, buf->len);
-        }
-        return -EINVAL;
-    }
-    /*
-     * FIXME: H-bit handling goes here
-     */
-#ifdef DEBUG_CONTROL
-    l2tp_log (LOG_DEBUG, "%s: control, cid = %d, Ns = %d, Nr = %d\n", __FUNCTION__,
-         c->cid, h->Ns, h->Nr);
-#endif
-    if (h->Ns != t->control_rec_seq_num)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG,
-                 "%s: Received out of order control packet on tunnel %d (got %d, expected %d)\n",
-                 __FUNCTION__, t->tid, h->Ns, t->control_rec_seq_num);
-        if (((h->Ns < t->control_rec_seq_num) && 
-            ((t->control_rec_seq_num - h->Ns) < 32768)) ||
-            ((h->Ns > t->control_rec_seq_num) &&
-            ((t->control_rec_seq_num - h->Ns) > 32768)))
-        {
-            /*
-               * Woopsies, they sent us a message we should have already received
-               * so we should send them a ZLB so they know
-               * for sure that we already have it.
-             */
-#ifdef DEBUG_ZLB
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG, "%s: Sending an updated ZLB in reponse\n",
-                     __FUNCTION__);
-#endif
-            zlb = new_outgoing (t);
-            control_zlb (zlb, t, c);
-            toss (zlb);
-        }
-        else if (!t->control_rec_seq_num && (t->tid == -1))
-        {
-            /* We made this tunnel just for this message, so let's
-               destroy it.  */
-            c->needclose = 0;
-            c->closing = -1;
-        }
-        return -EINVAL;
-    }
-    else
-    {
-        t->control_rec_seq_num++;
-        c->cnu = -1;
-    }
-    /*
-     * So we know what the other end has received
-     * so far
-     */
-
-    t->cLr = h->Nr;
-    if (t->sanity)
-    {
-        if (!CTBIT (h->ver))
-        {
-            if (DEBUG)
-            {
-                l2tp_log (LOG_DEBUG, "%s: Control bit not set\n", __FUNCTION__);
-            }
-            return -EINVAL;
-        }
-        if (!CLBIT (h->ver))
-        {
-            if (DEBUG)
-            {
-                l2tp_log (LOG_DEBUG, "%s: Length bit not set\n", __FUNCTION__);
-            }
-            return -EINVAL;
-        }
-        if (!CFBIT (h->ver))
-        {
-            if (DEBUG)
-            {
-                l2tp_log (LOG_DEBUG, "%s: Flow bit not set\n", __FUNCTION__);
-            }
-            return -EINVAL;
-        }
-        if (CVER (h->ver) != VER_L2TP)
-        {
-            if (DEBUG)
-            {
-                if (CVER (h->ver) == VER_PPTP)
-                {
-                    l2tp_log (LOG_DEBUG,
-                         "%s: PPTP packet received\n", __FUNCTION__);
-                }
-                else if (CVER (h->ver) < VER_L2TP)
-                {
-                    l2tp_log (LOG_DEBUG,
-                         "%s: L2F packet received\n", __FUNCTION__);
-                }
-                else
-                {
-                    l2tp_log (LOG_DEBUG,
-                         "%s: Unknown version received\n", __FUNCTION__);
-                }
-            }
-            return -EINVAL;
-        }
-
-    }
-#endif
-    return 0;
-}
-
-inline int check_payload (struct buffer *buf, struct tunnel *t,
-                          struct call *c)
-{
-    /*
-     * Check if this is a valid payload
-     * or not.  Returns 0 on success.
-     */
-
-    int ehlen = MIN_PAYLOAD_HDR_LEN;
-    struct payload_hdr *h = (struct payload_hdr *) (buf->start);
-    if (!c)
-    {
-        if (DEBUG)
-        {
-            l2tp_log (LOG_DEBUG, "%s: Aempted to send payload on tunnel\n",
-                 __FUNCTION__);
-        }
-        return -EINVAL;
-    }
-    if (buf->len < MIN_PAYLOAD_HDR_LEN)
-    {
-        /* has to be at least MIN_PAYLOAD_HDR_LEN 
-           no matter what.  we'll look more later */
-        if (DEBUG)
-        {
-            l2tp_log (LOG_DEBUG, "%s:Recieved to small of packet\n", __FUNCTION__);
-        }
-        return -EINVAL;
-    }
-#ifdef SANITY
-    if (t->sanity)
-    {
-        if (PTBIT (h->ver))
-        {
-            if (DEBUG)
-            {
-                l2tp_log (LOG_DEBUG, "%s Control bit set\n", __FUNCTION__);
-            }
-            return -EINVAL;
-        }
-        if (PLBIT (h->ver))
-            ehlen += 2;         /* Should have length information */
-        if (PFBIT (h->ver))
-        {
-/*			if (!c->fbit && !c->ourfbit) {
-				if (DEBUG)
-					l2tp_log(LOG_DEBUG,"%s: flow bit set, but no RWS negotiated.\n",__FUNCTION__);
-				return -EINVAL;
-			} */
-            ehlen += 4;         /* Should have Ns and Nr too */
-        }
-/*		if (!PFBIT(h->ver)) {
-			if (c->fbit || c->ourfbit) {
-				if (DEBUG)
-					l2tp_log(LOG_DEBUG, "%s: no flow bit, but RWS was negotiated.\n",__FUNCTION__);
-				return -EINVAL;;
-			}
-		} */
-        if (PSBIT (h->ver))
-            ehlen += 4;         /* Offset information */
-        if (PLBIT (h->ver))
-            ehlen += h->length; /* include length if available */
-        if (PVER (h->ver) != VER_L2TP)
-        {
-            if (DEBUG)
-            {
-                if (PVER (h->ver) == VER_PPTP)
-                {
-                    l2tp_log (LOG_DEBUG, "%s: PPTP packet received\n",
-                         __FUNCTION__);
-                }
-                else if (CVER (h->ver) < VER_L2TP)
-                {
-                    l2tp_log (LOG_DEBUG, "%s: L2F packet received\n",
-                         __FUNCTION__);
-                }
-                else
-                {
-                    l2tp_log (LOG_DEBUG, "%s: Unknown version received\n",
-                         __FUNCTION__);
-                }
-            }
-            return -EINVAL;
-        }
-        if ((buf->len < ehlen) && !PLBIT (h->ver))
-        {
-            if (DEBUG)
-            {
-                l2tp_log (LOG_DEBUG, "%s payload too small (%d < %d)\n",
-                     __FUNCTION__, buf->len, ehlen);
-            }
-            return -EINVAL;
-        }
-        if ((buf->len != h->length) && PLBIT (h->ver))
-        {
-            if (DEBUG)
-            {
-                l2tp_log (LOG_DEBUG, "%s: size mismatch (%d != %d)\n",
-                     __FUNCTION__, buf->len, h->length);
-            }
-            return -EINVAL;
-        }
-    }
-#endif
-    return 0;
-}
-inline int expand_payload (struct buffer *buf, struct tunnel *t,
-                           struct call *c)
-{
-    /*
-     * Expands payload header.  Does not check for valid header,
-     * check_payload() should already be called as a prerequisite.
-     */
-    struct payload_hdr *h = (struct payload_hdr *) (buf->start);
-    _u16 *r = (_u16 *) h;       /* Nice to have raw word pointers */
-    struct payload_hdr *new_hdr;
-    int ehlen = 0;
-    /*
-     * We first calculate our offset
-     */
-    if (!PLBIT (h->ver))
-        ehlen += 2;             /* Should have length information */
-    if (!PFBIT (h->ver))
-        ehlen += 4;             /* Should have Ns and Nr too */
-    if (!PSBIT (h->ver))
-        ehlen += 4;             /* Offset information */
-    if (ehlen)
-    {
-        /*
-         * If this payload is missing any information, we'll
-         * fill it in
-         */
-        new_hdr = (struct payload_hdr *) (buf->start - ehlen);
-        if ((void *) new_hdr < (void *) buf->rstart)
-        {
-            l2tp_log (LOG_WARNING, "%s: not enough space to decompress frame\n",
-                 __FUNCTION__);
-            return -EINVAL;
-
-        };
-        new_hdr->ver = *r;
-        if (PLBIT (new_hdr->ver))
-        {
-            r++;
-            new_hdr->length = *r;
-        }
-        else
-        {
-            new_hdr->length = buf->len + ehlen;
-        };
-        r++;
-        new_hdr->tid = *r;
-        r++;
-        new_hdr->cid = *r;
-        if (PFBIT (new_hdr->ver))
-        {
-            r++;
-            new_hdr->Ns = *r;
-            r++;
-            new_hdr->Nr = *r;
-        }
-        else
-        {
-            new_hdr->Nr = c->data_seq_num;
-            new_hdr->Ns = c->data_rec_seq_num;
-        };
-        if (PSBIT (new_hdr->ver))
-        {
-            r++;
-            new_hdr->o_size = *r;
-            r++;
-            new_hdr->o_pad = *r;
-        }
-        else
-        {
-            new_hdr->o_size = 0;
-            new_hdr->o_pad = 0;
-        }
-    }
-    else
-        new_hdr = h;
-    /*
-       * Handle sequence numbers
-       *
-     */
-/*  JLM	if (PRBIT(new_hdr->ver)) {
-		if (c->pSr > new_hdr->Ns) {
-			l2tp_log(LOG_DEBUG, "%s: R-bit set with Ns < pSr!\n",__FUNCTION__);
-			return -EINVAL;
-		}
-#ifdef DEBUG_FLOW
-		l2tp_log(LOG_DEBUG, "%s: R-bit set on packet %d\n",__FUNCTION__,new_hdr->Ns);
-#endif
-		c->pSr=new_hdr->Ns;
-	} */
-#ifdef DEBUG_PAYLOAD
-    l2tp_log (LOG_DEBUG, "%s: payload, cid = %d, Ns = %d, Nr = %d\n", __FUNCTION__,
-         c->cid, new_hdr->Ns, new_hdr->Nr);
-#endif
-    if (new_hdr->Ns != c->data_seq_num)
-    {
-        /* RFC1982-esque comparison of serial numbers */
-        if (((new_hdr->Ns < c->data_rec_seq_num) && 
-            ((c->data_rec_seq_num - new_hdr->Ns) < 32768)) ||
-            ((new_hdr->Ns > c->data_rec_seq_num) && 
-            ((c->data_rec_seq_num - new_hdr->Ns) > 32768)))
-        {
-#ifdef DEBUG_FLOW
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Already seen this packet before (%d)\n",
-                     __FUNCTION__, new_hdr->Ns);
-#endif
-            return -EINVAL;
-        }
-        else if (new_hdr->Ns <= c->data_rec_seq_num + PAYLOAD_FUDGE)
-        {
-            /* FIXME: I should buffer for out of order packets */
-#ifdef DEBUG_FLOW
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Oops, lost a packet or two (%d).  continuing...\n",
-                     __FUNCTION__, new_hdr->Ns);
-#endif
-            c->data_rec_seq_num = new_hdr->Ns;
-        }
-        else
-        {
-#ifdef DEBUG_FLOW
-            if (DEBUG)
-                l2tp_log (LOG_DEBUG,
-                     "%s: Received out of order payload packet (%d)\n",
-                     __FUNCTION__, new_hdr->Ns);
-#endif
-            return -EINVAL;
-        }
-    }
-    else
-    {
-        c->data_rec_seq_num++;
-        c->pnu = -1;
-    }
-    /*
-     * Check to see what the last thing
-     * we got back was
-     */
-    c->pLr = new_hdr->Nr;
-    buf->start = new_hdr;
-    buf->len += ehlen;
-    return 0;
-}
-
-void send_zlb (void *data)
-{
-    /*
-     * Send a ZLB.  This procedure should be schedule()able
-     */
-    struct call *c;
-    struct tunnel *t;
-    struct buffer *buf;
-    c = (struct call *) data;
-    if (!c)
-    {
-        l2tp_log (LOG_WARNING, "%s: called on NULL call\n", __FUNCTION__);
-        return;
-    }
-    t = c->container;
-    if (!t)
-    {
-        l2tp_log (LOG_WARNING, "%s: called on call with NULL container\n",
-             __FUNCTION__);
-        return;
-    }
-    /* Update the counter so we know what Lr was when we last transmited a ZLB */
-    c->prx = c->data_rec_seq_num;
-    buf = new_payload (t->peer);
-    add_payload_hdr (t, c, buf);
-    c->data_seq_num--;                   /* We don't increment on ZLB's */
-    c->zlb_xmit = NULL;
-#ifdef DEBUG_ZLB
-    l2tp_log (LOG_DEBUG, "%s: sending payload ZLB\n", __FUNCTION__);
-#endif
-    udp_xmit (buf, t);
-    toss (buf);
-}
-
-inline int call_write_packet (struct buffer *buf, struct tunnel *t, struct call *c,
-                         int convert)
-{
-    /*
-     * Write a packet, doing sync->async conversion if
-     * necessary
-     */
-    int x;
-    unsigned char e;
-    int err;
-    static unsigned char wbuf[MAX_RECV_SIZE];
-    int pos = 0;
-
-    if (c->fd < 0)
-    {
-        if (DEBUG)
-            l2tp_log (LOG_DEBUG, "%s: tty is not open yet.\n", __FUNCTION__);
-        return -EIO;
-    }
-    /*
-     * Skip over header 
-     */
-    buf->start += sizeof (struct payload_hdr);
-    buf->len -= sizeof (struct payload_hdr);
-
-    c->rx_pkts++;
-    c->rx_bytes += buf->len;
-
-    /*
-     * FIXME:  What about offset?
-     */
-    while (!convert)
-    {
-        /* We are given async frames, so write them
-           directly to the tty */
-        err = write (c->fd, buf->start, buf->len);
-        if (err == buf->len)
-        {
-            return 0;
-        }
-        else if (err == 0)
-        {
-            l2tp_log (LOG_WARNING, "%s: wrote no bytes of async packet\n",
-                 __FUNCTION__);
-            return -EINVAL;
-        }
-        else if (err < 0)
-        {
-            if ((errno == EAGAIN) || (errno == EINTR))
-            {
-                continue;
-            }
-            else
-            {
-                l2tp_log (LOG_WARNING, "%s: async write failed: %s\n", __FUNCTION__,
-                     strerror (errno));
-            }
-        }
-        else if (err < buf->len)
-        {
-            l2tp_log (LOG_WARNING, "%s: short write (%d of %d bytes)\n", __FUNCTION__,
-                 err, buf->len);
-            return -EINVAL;
-        }
-        else if (err > buf->len)
-        {
-            l2tp_log (LOG_WARNING, "%s: write returned LONGER than buffer length?\n",
-                 __FUNCTION__);
-            return -EINVAL;
-        }
-    }
-
-    /*
-     * sync->async conversion if we're doing sync frames
-     * since the pppd driver will expect async frames
-     * Write leading flag character
-     */
-
-    add_fcs (buf);
-    e = PPP_FLAG;
-    wbuf[pos++] = e;
-    for (x = 0; x < buf->len; x++)
-    {
-        // we must at least still have 3 bytes left in the worst case scenario:
-        // 1 for a possible escape, 1 for the value and 1 to end the PPP stream.
-        if(pos >= (sizeof(wbuf) - 4)) {
-            if(DEBUG)
-                l2tp_log(LOG_CRIT, "%s: rx packet is too big after PPP encoding (size %u, max is %u)\n",
-                                __FUNCTION__, buf->len, MAX_RECV_SIZE);
-            return -EINVAL;
-        }
-        e = *((char *) buf->start + x);
-        if ((e < 0x20) || (e == PPP_ESCAPE) || (e == PPP_FLAG))
-        {
-            /* Escape this */
-            e = e ^ 0x20;
-            wbuf[pos++] = PPP_ESCAPE;
-        }
-        wbuf[pos++] = e;
-
-    }
-    wbuf[pos++] = PPP_FLAG;
-
-#if 0
-    if(DEBUG) {
-      l2tp_log(LOG_DEBUG, "after sync->async, expanded %d->%d\n",
-	       buf->len, pos);
-    }
-#endif
-
-    x = write (c->fd, wbuf, pos);
-    if (x < pos)
-    {
-      if (DEBUG)
-	l2tp_log (LOG_WARNING, "%s: %s(%d)\n", __FUNCTION__, strerror (errno),
-		  errno);
-
-        if (!(errno == EINTR) && !(errno == EAGAIN))
-        {
-            /*
-               * I guess pppd died.  we'll pretend
-               * everything ended normally
-             */
-            c->needclose = -1;
-            c->fd = -1;
-            return -EIO;
-        }
-    }
-    return 0;
-}
-
-void handle_special (struct buffer *buf, struct call *c, _u16 call)
-{
-    /*
-       * This procedure is called when we have received a packet
-       * on a call which doesn't exist in our tunnel.  We want to
-       * send back a ZLB to keep the tunnel alive, on that particular
-       * call if it was a CDN, otherwise, send a CDN to notify them
-       * that this call has been terminated.
-     */
-    struct buffer *outgoing;
-    struct tunnel *t = c->container;
-    /* Don't do anything unless it's a control packet */
-    if (!CTBIT (*((_u16 *) buf->start)))
-        return;
-    /* Temporarily, we make the tunnel have cid of call instead of 0,
-       but we need to stop any scheduled events (like Hello's in
-       particular) which might use this value */
-    c->cid = call;
-    if (!check_control (buf, t, c))
-    {
-        if (buf->len == sizeof (struct control_hdr))
-        {
-            /* If it's a ZLB, we ignore it */
-            if (gconfig.debug_tunnel)
-                l2tp_log (LOG_DEBUG, "%s: ZLB for closed call\n", __FUNCTION__);
-            c->cid = 0;
-            return;
-        }
-        /* Make a packet with the specified call number */
-        outgoing = new_outgoing (t);
-        /* FIXME: If I'm not a CDN, I need to send a CDN */
-        control_zlb (buf, t, c);
-        c->cid = 0;
-        toss (buf);
-    }
-    else
-    {
-        c->cid = 0;
-        if (gconfig.debug_tunnel)
-            l2tp_log (LOG_DEBUG, "%s: invalid control packet\n", __FUNCTION__);
-    }
-}
-
-inline int handle_packet (struct buffer *buf, struct tunnel *t,
-                          struct call *c)
-{
-    int res;
-/* tv code is commented out below
-#ifdef DEBUG_ZLB
-    struct timeval tv;
-#endif
-*/
-    if (CTBIT (*((_u16 *) buf->start)))
-    {
-        /* We have a control packet */
-        if (!check_control (buf, t, c))
-        {
-            c->msgtype = -1;
-            if (buf->len == sizeof (struct control_hdr))
-            {
-#ifdef DEBUG_ZLB
-                l2tp_log (LOG_DEBUG, "%s: control ZLB received\n", __FUNCTION__);
-#endif
-                t->control_rec_seq_num--;
-                c->cnu = 0;
-                if (c->needclose && c->closing)
-                {
-                    if (c->container->cLr >= c->closeSs)
-                    {
-#ifdef DEBUG_ZLB
-                        l2tp_log (LOG_DEBUG, "%s: ZLB for closing message found\n",
-                             __FUNCTION__);
-#endif
-                        c->needclose = 0;
-                        /* Trigger final closing of call */
-                    }
-                }
-                return 0;
-            }
-            else if (!handle_avps (buf, t, c))
-            {
-                return control_finish (t, c);
-            }
-            else
-            {
-                if (gconfig.debug_tunnel)
-                    l2tp_log (LOG_DEBUG, "%s: bad AVP handling!\n", __FUNCTION__);
-                return -EINVAL;
-            }
-        }
-        else
-        {
-	    if(DEBUG)
-        	l2tp_log (LOG_DEBUG, "%s: bad control packet!\n", __FUNCTION__);
-            return -EINVAL;
-        }
-    }
-    else
-    {
-        if (!check_payload (buf, t, c))
-        {
-            if (!expand_payload (buf, t, c))
-            {
-                if (buf->len > sizeof (struct payload_hdr))
-                {
-/*					if (c->throttle) {
-						if (c->pSs > c->pLr + c->rws) {
-#ifdef DEBUG_FLOW
-							l2tp_log(LOG_DEBUG, "%s: not yet dethrottling call\n",__FUNCTION__);
-#endif
-						} else {
-#ifdef DEBUG_FLOW
-							l2tp_log(LOG_DEBUG, "%s: dethrottling call\n",__FUNCTION__);
-#endif
-							if (c->dethrottle) deschedule(c->dethrottle);
-							c->dethrottle=NULL;
-							c->throttle = 0;
-						}
-					} */
-/*	JLM				res = call_write_packet(buf,t,c, c->frame & SYNC_FRAMING); */
-                    res = call_write_packet (buf, t, c, SYNC_FRAMING);
-                    if (res)
-                        return res;
-                    /* 
-                       * Assuming we wrote to the ppp driver okay, we should
-                       * do something about ZLB's unless *we* requested no
-                       * window size or if they we have turned off our fbit. 
-                     */
-
-/*					if (c->ourfbit && (c->ourrws > 0)) {
-						if (c->pSr >= c->prx + c->ourrws - 2) {
-						We've received enough to fill our receive window.  At
-						this point, we should immediately send a ZLB!
-#ifdef DEBUG_ZLB
-							l2tp_log(LOG_DEBUG, "%s: Sending immediate ZLB!\n",__FUNCTION__);
-#endif
-							if (c->zlb_xmit) {
-							Deschedule any existing zlb_xmit's
-								deschedule(c->zlb_xmit);
-								c->zlb_xmit = NULL;
-							}
-							send_zlb((void *)c);
-						} else {
-						struct timeval tv;
-						We need to schedule sending a ZLB.  FIXME:  Should
-						be 1/4 RTT instead, when rate adaptive stuff is
-						in place. Spec allows .5 seconds though
-							tv.tv_sec = 0;
-							tv.tv_usec = 500000;
-							if (c->zlb_xmit)
-								deschedule(c->zlb_xmit);
-#ifdef DEBUG_ZLB
-							l2tp_log(LOG_DEBUG, "%s: scheduling ZLB\n",__FUNCTION__);
-#endif
-							c->zlb_xmit = schedule(tv, &send_zlb, (void *)c);
-						}
-					} */
-                    return 0;
-                }
-                else if (buf->len == sizeof (struct payload_hdr))
-                {
-#ifdef DEBUG_ZLB
-                    l2tp_log (LOG_DEBUG, "%s: payload ZLB received\n",
-                         __FUNCTION__);
-#endif
-/*					if (c->throttle) {
-						if (c->pSs > c->pLr + c->rws) {
-#ifdef DEBUG_FLOW
-							l2tp_log(LOG_DEBUG, "%s: not yet dethrottling call\n",__FUNCTION__);
-#endif
-						} else {
-#ifdef DEBUG_FLOW
-							l2tp_log(LOG_DEBUG, "%s: dethrottling call\n",__FUNCTION__);
-#endif
-							if (c->dethrottle)
-								deschedule(c->dethrottle);
-							c->dethrottle=NULL;
-							c->throttle = 0;
-						}
-					} */
-                    c->data_rec_seq_num--;
-                    return 0;
-                }
-                else
-                {
-		    if(DEBUG)
-                	l2tp_log (LOG_DEBUG, "%s: payload too small!\n", __FUNCTION__);
-                    return -EINVAL;
-                }
-            }
-            else
-            {
-                if (gconfig.debug_tunnel)
-                    l2tp_log (LOG_DEBUG, "%s: unable to expand payload!\n",
-                         __FUNCTION__);
-                return -EINVAL;
-            }
-        }
-        else
-        {
-	    if(DEBUG)
-        	l2tp_log (LOG_DEBUG, "%s: invalid payload packet!\n", __FUNCTION__);
-            return -EINVAL;
-        }
-    }
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/control.h ppp-2.4.4/pppd/plugins/pppol2tp/control.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/control.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/control.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,67 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Control Packet Handling header
- *
- */
-
-#include "common.h"
-
-/* Declaration of FIFO used for maintaining
-   a reliable control connection, as well
-   as for queueing stuff for the individual
-   threads */
-#ifndef _CONTROL_H
-#define _CONTROL_H
-/* Control message types  for vendor-ID 0, placed in the VALUE
-   field of AVP requests */
-
-/* Control Connection Management */
-#define SCCRQ 	1               /* Start-Control-Connection-Request */
-#define SCCRP 	2               /* Start-Control-Connection-Reply */
-#define SCCCN 	3               /* Start-Control-Connection-Connected */
-#define StopCCN 4               /* Stop-Control-Connection-Notification */
-/* 5 is reserved */
-#define Hello	6               /* Hello */
-/* Call Management */
-#define OCRQ	7               /* Outgoing-Call-Request */
-#define OCRP	8               /* Outgoing-Call-Reply */
-#define OCCN	9               /* Outgoing-Call-Connected */
-#define ICRQ	10              /* Incoming-Call-Request */
-#define ICRP	11              /* Incoming-Call-Reply */
-#define ICCN	12              /* Incoming-Call-Connected */
-/* 13 is reserved */
-#define CDN	14              /* Call-Disconnect-Notify */
-/* Error Reporting */
-#define WEN	15              /* WAN-Error-Notify */
-/* PPP Sesssion Control */
-#define SLI	16              /* Set-Link-Info */
-
-#define MAX_MSG 16
-
-#define TBIT 0x8000
-#define LBIT 0x4000
-#define RBIT 0x2000
-#define FBIT 0x0800
-
-extern int handle_packet (struct buffer *, struct tunnel *, struct call *);
-extern struct buffer *new_outgoing (struct tunnel *);
-extern void add_control_hdr (struct tunnel *t, struct call *c,
-                             struct buffer *);
-extern int control_finish (struct tunnel *t, struct call *c);
-extern void control_zlb (struct buffer *, struct tunnel *, struct call *);
-extern void recycle_outgoing (struct buffer *, struct sockaddr_in);
-extern void handle_special (struct buffer *, struct call *, _u16);
-extern void hello (void *);
-extern void send_zlb (void *);
-extern void dethrottle (void *);
-
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/file.c ppp-2.4.4/pppd/plugins/pppol2tp/file.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/file.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/file.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,87 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * File format handling
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#include <time.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-
-#include "l2tp.h"
-
-struct lac *laclist;
-struct global gconfig;
-
-struct lac *new_lac ()
-{
-    struct lac *tmp;
-    tmp = (struct lac *) zalloc (sizeof (struct lac));
-    if (!tmp)
-    {
-        l2tp_log (LOG_CRIT, "%s: Unable to allocate memory for lac entry!\n",
-             __FUNCTION__);
-        return NULL;
-    }
-    tmp->rsched = NULL;
-    tmp->lns = 0;
-    tmp->tun_rws = 4;
-    tmp->call_rws = 10;
-    tmp->hbit = 0;
-    tmp->lbit = 0;
-    tmp->t = NULL;
-    tmp->challenge = 0;
-    tmp->active = 0;
-    return tmp;
-}
-
-
-
-int init_config (char *lns) {
-    char *port;
-    
-    gconfig.port = UDP_LISTEN_PORT;
-    gconfig.listenaddr = htonl(INADDR_ANY); /* Default is to bind (listen) to all interfaces */
-    gconfig.debug_avp = 0;
-    gconfig.debug_network = 0;
-    gconfig.packet_dump = 0;
-    gconfig.debug_tunnel = 0;
-    gconfig.debug_state = 0;
-    gconfig.ipsecsaref = 0;
-
-    if( (laclist = new_lac()) ) {
-	if( !(laclist->lns = (struct host*)zalloc(sizeof(struct host))) ) {
-	    l2tp_log (LOG_CRIT, "%s: Unable to allocate memory for lns entry!\n",
-             __FUNCTION__);
-	     free(laclist);
-	     laclist = NULL;
-	     return -1;
-	}
-	memset(laclist->lns, 0, sizeof(struct host));
-	if( (port = strchr(lns, ':')) ) {
-	    memcpy(laclist->lns->hostname, lns, MIN((int)(port - lns), (sizeof(laclist->lns->hostname) - 1)));
-	    laclist->lns->port = atoi(port + 1);
-	} else {
-	    strncpy(laclist->lns->hostname, lns, sizeof(laclist->lns->hostname) - 1);
-	    laclist->lns->port = UDP_LISTEN_PORT;
-	}
-    }
-    
-    return 0;
-}
-
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/file.h ppp-2.4.4/pppd/plugins/pppol2tp/file.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/file.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/file.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,71 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * File format handling header file
- *
- */
-
-#ifndef _FILE_H
-#define _FILE_H
-
-#define STRLEN 80               /* Length of a string */
-
-struct host
-{
-    char hostname[STRLEN];
-    int port;
-};
-
-#define AUTH_FILE "/etc/ppp/l2tp-secrets"
-
-#define CONTEXT_GLOBAL 	1
-#define CONTEXT_LNS	   	2
-#define CONTEXT_LAC		3
-#define CONTEXT_DEFAULT	256
-
-#define SENSE_ALLOW -1
-#define SENSE_DENY 0
-
-struct lac
-{
-    struct host *lns;           /* LNS's we can connect to */
-    struct schedule_entry *rsched;
-    int tun_rws;                /* Receive window size (tunnel) */
-    int call_rws;               /* Call rws */
-    int active;                 /* Is this connection in active use? */
-    int hbit;                   /* Permit hidden AVP's? */
-    int lbit;                   /* Use the length field? */
-    int challenge;              /* Challenge authenticate the peer? */
-    char peername[STRLEN];      /* Force peer name to this */
-    char hostname[STRLEN];      /* Hostname to report */
-    char entname[STRLEN];       /* Name of this entry */
-    int idle;                   /* Idle timeout in seconds */
-    struct tunnel *t;           /* Our tunnel */
-    struct call *c;             /* Our call */
-};
-
-struct global
-{
-    unsigned int listenaddr;    /* IP address to bind to */ 
-    int port;                   /* Port number to listen to */
-    int packet_dump;		/* Dump (print) all packets? */
-    int debug_avp;		/* Print AVP debugging info? */
-    int debug_network;		/* Print network debugging info? */
-    int debug_tunnel;		/* Print tunnel debugging info? */
-    int debug_state;		/* Print FSM debugging info? */
-    int ipsecsaref;
-};
-
-extern struct global gconfig;   /* Global configuration options */
-
-extern struct lac *laclist;     /* All LAC entries */
-extern int init_config(char *lns);
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/ipsecmast.h ppp-2.4.4/pppd/plugins/pppol2tp/ipsecmast.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/ipsecmast.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/ipsecmast.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,14 +0,0 @@
-#ifndef _IPSECMAST_H
-#define _IPSECMAST_H
-
-#ifndef IP_IPSEC_REFINFO
-#define IP_IPSEC_REFINFO 18
-#endif
-
-#ifndef IPSEC_SAREF_NULL
-typedef uint32_t IPsecSAref_t;
-
-#define IPSEC_SAREF_NULL ((IPsecSAref_t)0)
-#endif
-
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/l2tp.c ppp-2.4.4/pppd/plugins/pppol2tp/l2tp.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/l2tp.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/l2tp.c	2013-01-17 16:41:25.503156445 +0400
@@ -46,7 +46,7 @@
 #include <linux/if_ppp.h>
 #include <linux/if_pppox.h>
 #include <linux/if_pppol2tp.h>
-#include "l2tp.h"
+#include "common.h"
 
 /* should be added to system's socket.h... */
 #ifndef SOL_PPPOL2TP
@@ -58,42 +58,15 @@
 static int setdevname_pppol2tp();
 static char * pppol2tp_lns = "";
 
-static bool pppol2tp_recv_seq = 0;
-static bool pppol2tp_send_seq = 0;
-static int pppol2tp_debug_mask = 0;
-static int pppol2tp_reorder_timeout = 0;
 static char pppol2tp_ifname[32] = { 0, };
 
 static int device_got_set = 0;
 struct channel pppol2tp_channel;
 static int pppol2tp_num = 0;
 
-static void (*old_snoop_recv_hook)(unsigned char *p, int len) = NULL;
-static void (*old_snoop_send_hook)(unsigned char *p, int len) = NULL;
-static void (*old_ip_up_hook)(void) = NULL;
-static void (*old_ip_down_hook)(void) = NULL;
-
-/* Hook provided to allow other plugins to handle ACCM changes */
-void (*pppol2tp_send_accm_hook)(int tunnel_id, int session_id, uint32_t send_accm, uint32_t recv_accm) = NULL;
-
-/* Hook provided to allow other plugins to handle IP up/down */
-void (*pppol2tp_ip_updown_hook)(int tunnel_id, int session_id, int up) = NULL;
-
 static option_t pppol2tp_options[] = {
-	{ "l2tp_send_seq", o_bool, &pppol2tp_send_seq,
-	  "L2TP enable sequence numbers in transmitted data packets. Default off.", 
-	  OPT_PRIO | OPRIO_CFGFILE },
 	{ "l2tp_lns", o_string, &pppol2tp_lns,
           "L2TP lns server" },
-	{ "l2tp_recv_seq", o_bool, &pppol2tp_recv_seq,
-	  "L2TP enforce sequence numbers in received data packets. Default off.", 
-	  OPT_PRIO | OPRIO_CFGFILE },
-	{ "l2tp_reorderto", o_int, &pppol2tp_reorder_timeout,
-	  "L2TP data packet reorder timeout. Default 0 (no reordering).", 
-	  OPT_PRIO },
-	{ "l2tp_debug_mask", o_int, &pppol2tp_debug_mask,
-	  "L2TP debug mask. Default: no debug.", 
-	  OPT_PRIO },
 	{ "l2tp_ifname", o_string, &pppol2tp_ifname,
 	  "L2TP interface name of PPP interface",
 	  OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, 16 },
@@ -140,12 +113,11 @@
 static int connect_pppol2tp(void) {
 	 int isock_fd;
 	
-    if( l2tp_init(pppol2tp_lns) ) {
+    if( l2tp_control_init(pppol2tp_lns) < 0 ) {
 	fatal("l2tp_init failed");
     } else {
-   	l2tp_wait_socket();
-   	 if( (isock_fd = l2tp_get_socket()) < 0 ) {
-   		l2tp_exit();
+   	if( (isock_fd = l2tp_control_get_socket()) < 0 ) {
+   		l2tp_control_exit();
 	    fatal("l2tp_get_socket failed");
 		}
     }
@@ -153,11 +125,11 @@
 }
 
 static void disconnect_pppol2tp(void) {
-    l2tp_exit();
+    l2tp_control_exit();
 }
 
 static void clean_pppol2tp(void) {
-    l2tp_exit();
+    l2tp_control_exit();
 }
 
 static void send_config_pppol2tp(int mtu,
@@ -165,13 +137,9 @@
 			      int pcomp,
 			      int accomp)
 {
-    int on = 1;
-    char reorderto[16];
-    char tid[8];
-    char sid[8];
     int isock_fd;
     
-    if( (isock_fd = l2tp_get_socket()) < 0 ) return;
+    if( (isock_fd = l2tp_control_get_socket()) < 0 ) return;
     
 	if (pppol2tp_ifname[0]) {
 		struct ifreq ifr;
@@ -184,47 +152,14 @@
 			strlcpy(ifr.ifr_newname, pppol2tp_ifname, sizeof(ifr.ifr_name));
 			ioctl(fd, SIOCSIFNAME, (caddr_t) &ifr);
 			strlcpy(ifname, pppol2tp_ifname, 32);
-			if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
-				dbglog("ppp%d: interface name %s", ifunit, ifname);
-			}
 		}
 		close(fd);
 	}
 
 	if ((lcp_allowoptions[0].mru > 0) && (mtu > lcp_allowoptions[0].mru)) {
-		warn("Overriding mtu %d to %d", mtu, lcp_allowoptions[0].mru);
 		mtu = lcp_allowoptions[0].mru;
 	}
 	netif_set_mtu(ifunit, mtu);
-
-	reorderto[0] = '\0';
-	if (pppol2tp_reorder_timeout > 0)
-		sprintf(&reorderto[0], "%d ", pppol2tp_reorder_timeout);
-	tid[0] = '\0';
-	sid[0] = '\0';
-	
-	if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL)
-	    dbglog("PPPoL2TP options: %s%s%s%s%s%s%s%s%sdebugmask %d", 
-	       pppol2tp_recv_seq ? "recvseq " : "",
-	       pppol2tp_send_seq ? "sendseq " : "",
-	       "",
-	       pppol2tp_reorder_timeout ? "reorderto " : "", reorderto,
-	       "", tid,
-	       "", sid,
-	       pppol2tp_debug_mask);	
-
-	if (pppol2tp_recv_seq)
-		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_RECVSEQ, &on, sizeof(on)) < 0)
-			fatal("setsockopt(PPPOL2TP_RECVSEQ): %m");
-	if (pppol2tp_send_seq)
-		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_SENDSEQ, &on, sizeof(on)) < 0)
-			fatal("setsockopt(PPPOL2TP_SENDSEQ): %m");
-	if (pppol2tp_reorder_timeout)
-		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_REORDERTO, &pppol2tp_reorder_timeout, sizeof(pppol2tp_reorder_timeout)) < 0)
-			fatal("setsockopt(PPPOL2TP_REORDERTO): %m");
-	if (pppol2tp_debug_mask)
-		if (setsockopt(isock_fd, SOL_PPPOL2TP, PPPOL2TP_SO_DEBUG, &pppol2tp_debug_mask, sizeof(pppol2tp_debug_mask)) < 0)
-			fatal("setsockopt(PPPOL2TP_DEBUG): %m");
 }
 
 static void recv_config_pppol2tp(int mru,
@@ -234,15 +169,13 @@
 {
 	int isock_fd;
 	
-	if( (isock_fd = l2tp_get_socket()) < 0 ) return;
+	if( (isock_fd = l2tp_control_get_socket()) < 0 ) return;
 	
 	if ((lcp_allowoptions[0].mru > 0) && (mru > lcp_allowoptions[0].mru)) {
-		warn("Overriding mru %d to mtu value %d", mru, lcp_allowoptions[0].mru);
 		mru = lcp_allowoptions[0].mru;
 	}
 	if ((ifunit >= 0) && ioctl(isock_fd, PPPIOCSMRU, (caddr_t) &mru) < 0) {
 		//ignore
-		//error("Couldn't set PPP MRU: %m");
 	}
 }
 
@@ -253,174 +186,10 @@
  * This code is derived from Roaring Penguin L2TP.
  *****************************************************************************/
 
-static void pppol2tp_lcp_snoop(unsigned char *buf, int len, int incoming)
-{
-	static bool got_send_accm = 0;
-	static bool got_recv_accm = 0;
-	static uint32_t recv_accm = 0xffffffff;
-	static uint32_t send_accm = 0xffffffff;
-	static bool snooping = 1;
-
-	uint16_t protocol;
-	uint16_t lcp_pkt_len;
-	int opt, opt_len;
-	int reject;
-	unsigned char const *opt_data;
-	uint32_t accm;
-
-	/* Skip HDLC header */
-	buf += 2;
-	len -= 2;
-
-	/* Unreasonably short frame?? */
-	if (len <= 0) return;	
-
-	/* Get protocol */
-	if (buf[0] & 0x01) {
-		/* Compressed protcol field */
-		protocol = buf[0];
-	} else {
-		protocol = ((unsigned int) buf[0]) * 256 + buf[1];
-	}
-
-	/* If it's a network protocol, stop snooping */
-	if (protocol <= 0x3fff) {
-		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
-			dbglog("Turning off snooping: Network protocol %04x found.", protocol);
-		}
-		snooping = 0;
-		return;
-	}
-
-	/* If it's not LCP, do not snoop */
-	if (protocol != 0xc021) {
-		return;
-	}
-
-	/* Skip protocol; go to packet data */
-	buf += 2;
-	len -= 2;
-
-	/* Unreasonably short frame?? */
-	if (len <= 0) return;
-
-	/* Look for Configure-Ack or Configure-Reject code */
-	if (buf[0] != CONFACK && buf[0] != CONFREJ) return;
-
-	reject = (buf[0] == CONFREJ);
-
-	lcp_pkt_len = ((unsigned int) buf[2]) * 256 + buf[3];
-
-	/* Something fishy with length field? */
-	if (lcp_pkt_len > len) return;
-
-	/* Skip to options */
-	len = lcp_pkt_len - 4;
-	buf += 4;
-
-	while (len > 0) {
-		/* Pull off an option */
-		opt = buf[0];
-		opt_len = buf[1];
-		opt_data = &buf[2];
-		if (opt_len > len || opt_len < 2) break;
-		len -= opt_len;
-		buf += opt_len;
-		if (pppol2tp_debug_mask & PPPOL2TP_MSG_DEBUG) {
-			dbglog("Found option type %02x; len %d", opt, opt_len);
-		}
-
-		/* We are specifically interested in ACCM */
-		if (opt == CI_ASYNCMAP && opt_len == 0x06) {
-			if (reject) {
-				/* ACCM negotiation REJECTED; use default */
-				accm = 0xffffffff;
-				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
-					dbglog("Rejected ACCM negotiation; defaulting (%s)", incoming ? "incoming" : "outgoing");
-				}
-				recv_accm = accm;
-				send_accm = accm;
-				got_recv_accm = 1;
-				got_send_accm = 1;
-			} else {
-				memcpy(&accm, opt_data, sizeof(accm));
-				if (pppol2tp_debug_mask & PPPOL2TP_MSG_DATA) {
-					dbglog("Found ACCM of %08x (%s)", accm, incoming ? "incoming" : "outgoing");
-				}
-				if (incoming) {
-					recv_accm = accm;
-					got_recv_accm = 1;
-				} else {
-					send_accm = accm;
-					got_send_accm = 1;
-				}
-			}
-
-			if (got_recv_accm && got_send_accm) {
-				if (pppol2tp_debug_mask & PPPOL2TP_MSG_CONTROL) {
-					dbglog("Telling L2TP: Send ACCM = %08x; Receive ACCM = %08x", send_accm, recv_accm);
-				}
-				if (pppol2tp_send_accm_hook != NULL) {
-					(*pppol2tp_send_accm_hook)(0, 0, send_accm, recv_accm);
-				}
-				got_recv_accm = 0;
-				got_send_accm = 0;
-			}
-		}
-	}
-}
-
-static void pppol2tp_lcp_snoop_recv(unsigned char *p, int len)
-{
-	if (old_snoop_recv_hook != NULL)
-		(*old_snoop_recv_hook)(p, len);
-	pppol2tp_lcp_snoop(p, len, 1);
-}
-
-static void pppol2tp_lcp_snoop_send(unsigned char *p, int len)
-{
-	if (old_snoop_send_hook != NULL)
-		(*old_snoop_send_hook)(p, len);
-	pppol2tp_lcp_snoop(p, len, 0);
-}
-
-/*****************************************************************************
- * Interface up/down events
- *****************************************************************************/
-
-static void pppol2tp_ip_up_hook(void)
-{
-	if (old_ip_up_hook != NULL)
-		(*old_ip_up_hook)();
-
-	if (pppol2tp_ip_updown_hook != NULL) {
-		(*pppol2tp_ip_updown_hook)(0, 0, 1);
-	}
-}
-
-static void pppol2tp_ip_down_hook(void)
-{
-	if (old_ip_down_hook != NULL)
-		(*old_ip_down_hook)();
-
-	if (pppol2tp_ip_updown_hook != NULL) {
-		(*pppol2tp_ip_updown_hook)(0, 0, 0);
-	}
-}
-
 /*****************************************************************************
  * Application init
  *****************************************************************************/
 
-static void pppol2tp_check_options(void)
-{
-	/* Hook up ip up/down hooks to send indicator to openl2tpd that the link is up */
-	old_ip_up_hook = ip_up_hook;
-	ip_up_hook = pppol2tp_ip_up_hook;
-	old_ip_down_hook = ip_down_hook;
-	ip_down_hook = pppol2tp_ip_down_hook;
-}
-
 void plugin_init(void)
 {
 #if defined(__linux__)
@@ -438,13 +207,13 @@
 struct channel pppol2tp_channel = {
     options: pppol2tp_options,
     process_extra_options: NULL,
-    check_options: &pppol2tp_check_options,
+    check_options: NULL,
     connect: &connect_pppol2tp,
     disconnect: &disconnect_pppol2tp,
     establish_ppp: &generic_establish_ppp,
     disestablish_ppp: &generic_disestablish_ppp,
-    send_config: &send_config_pppol2tp,
-    recv_config: &recv_config_pppol2tp, 
+    send_config: send_config_pppol2tp,
+    recv_config: recv_config_pppol2tp, 
     close: NULL,
     cleanup: &clean_pppol2tp, 
 };
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/l2tp_control.c ppp-2.4.4/pppd/plugins/pppol2tp/l2tp_control.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/l2tp_control.c	1970-01-01 03:00:00.000000000 +0300
+++ ppp-2.4.4/pppd/plugins/pppol2tp/l2tp_control.c	2013-01-17 16:41:29.111156521 +0400
@@ -0,0 +1,510 @@
+#include "common.h"
+
+static key_t key;
+static int iexit = 0;
+static int ikernel_sock = -1;
+static pid_t manager_pid = -1;
+
+PL2TP_STATE l2tp_init(const char *pcaddr, pid_t parent_pid) {
+	PL2TP_STATE pstate;
+	struct hostent *hp;
+	
+	if( !(hp = gethostbyname(pcaddr)) ) {
+		info("l2tp: gethostbyname error\n");
+		return NULL;
+	}
+	
+	if( !(pstate = malloc(sizeof(L2TP_STATE))) ) 
+		return NULL;
+	
+	memset(pstate, 0, sizeof(L2TP_STATE));
+	
+	pstate->addr = *(struct in_addr*)hp->h_addr;
+	gethostname(pstate->chostname, sizeof(pstate->chostname) - 1);
+	
+	info("l2tp: remote host: %s\n", inet_ntoa(pstate->addr));
+	
+	pstate->isock = -1;
+	pstate->parent_pid = parent_pid;
+	
+	return pstate;
+}
+
+void l2tp_free(PL2TP_STATE *ppstate) {
+	if( *ppstate ) {
+	
+		free(*ppstate);
+		*ppstate = NULL;
+	}
+}
+
+int l2tp_send(PL2TP_STATE pstate, const uint8_t *pdata, uint32_t ulen, int ims_to) {
+  fd_set write_fds;
+  struct timeval tv;
+
+  tv.tv_sec = 0;
+  tv.tv_usec = 1000 * ims_to;
+	
+  FD_ZERO(&write_fds);
+  FD_SET(pstate->isock, &write_fds);
+	
+  if( select(pstate->isock + 1, NULL, &write_fds, NULL, &tv) > 0 )
+	 return send(pstate->isock, pdata, ulen, 0);
+
+  return -1;
+}
+
+int l2tp_recv(PL2TP_STATE pstate, uint8_t **ppdata, int ims_to) {
+  fd_set read_fds;
+  struct timeval tv;
+  int iread;
+  uint8_t *pres;
+
+  tv.tv_sec = 0;
+  tv.tv_usec = 1000 * ims_to;
+	
+  FD_ZERO(&read_fds);
+  FD_SET(pstate->isock, &read_fds);
+  *ppdata = NULL;
+	
+  if( select(pstate->isock + 1, &read_fds, NULL, NULL, &tv) > 0 ) {
+  	 iread = 0;
+  	 if( !ioctl(pstate->isock, FIONREAD, &iread) && !iread ) return -1;
+  	 if( !iread || iread > L2TP_READ_NBUF ) iread = L2TP_READ_NBUF;
+  	 if( !(pres = (uint8_t*)malloc(iread)) ) return -2;
+  	 
+  	 *ppdata = pres;
+	 return recv(pstate->isock, pres, iread, 0);
+  }
+
+  return -3;
+}
+
+int l2tp_kernel_socket(PL2TP_STATE pstate) {
+   int shmid;
+	PSHT psegptr = NULL;
+	
+	key = ftok("/dev/shm/l2tp", 'S');
+	
+	if( (shmid = shmget(key, sizeof(SHT), 0)) == -1 ||
+		 (psegptr = (PSHT)shmat(shmid, 0, 0)) == (PSHT)-1 ) {
+		return -1;
+  	}
+  	
+	psegptr->ifd = pstate->isock;
+	psegptr->addr = pstate->addr;
+	psegptr->tid = pstate->tid;
+	psegptr->sid = pstate->sid;
+	psegptr->remtid = pstate->remtid;
+	psegptr->remsid = pstate->remsid;
+
+	shmdt(psegptr);	
+	return 0;
+}
+
+void l2tp_sync_nsnr(PL2TP_STATE pstate) {
+	FILE *fin;
+	char cline[128], *pses, *ptun, *pns, *pnr;
+	
+	if( !(fin = fopen("/proc/net/l2tp_tun", "r")) ) return;
+	
+	while( (fgets(cline, sizeof(cline) - 1, fin)) ) {
+		cline[sizeof(cline) - 1] = 0;
+		
+		pnr = NULL;
+		pses = cline;
+		if( (ptun = strchr(pses, ',')) ) *ptun++ = 0;
+		if( ptun && (pns = strchr(ptun, ',')) ) *pns++ = 0;
+		if( pns && (pnr = strchr(pns, ',')) ) *pnr++ = 0;
+		
+		if( pstate->sid == (uint16_t)atoi(pses) && 
+			 pstate->tid == (uint16_t)atoi(ptun) &&
+			 (uint16_t)atoi(pns) > 0 && (uint16_t)atoi(pnr) > 0 ) {
+			pstate->nr = pstate->remns = (uint16_t)atoi(pns);
+			pstate->ns = pstate->remnr = (uint16_t)atoi(pnr);
+		}
+	}
+	
+	fclose(fin);
+}
+
+int l2tp_connect(PL2TP_STATE pstate) {
+	struct sockaddr_in l2tp_local, l2tp_remote;
+	uint8_t *pdata;
+	int iret, iread, icnt;
+	long arg;
+	
+   if( (pstate->isock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) 
+        return -1;
+
+	l2tp_local.sin_family = AF_INET;
+   l2tp_local.sin_addr.s_addr = 0; 
+   l2tp_local.sin_port = htons (L2TP_PORT);
+   
+   l2tp_remote.sin_family = AF_INET;
+   l2tp_remote.sin_addr = pstate->addr;
+   l2tp_remote.sin_port = htons(L2TP_PORT);
+   
+   arg = 1; 
+   setsockopt(pstate->isock, SOL_SOCKET, SO_REUSEADDR, &arg, sizeof(arg));
+
+	if( bind(pstate->isock, (const struct sockaddr *)&l2tp_local, sizeof(l2tp_local)) < 0 ) {
+  		close_socket(pstate->isock);
+  		return -2;
+   }
+   
+   if( connect(pstate->isock, (const struct sockaddr *)&l2tp_remote, sizeof(l2tp_remote)) < 0 ) {
+	   close_socket(pstate->isock);
+	   return -3;
+   }
+   
+   iexit = 0;
+   icnt = 0;
+   
+   while( !iexit ) {
+  		switch( pstate->istage ) {
+  		case 0: /* initial, send SCCRQ */
+  			if( pstate->ilast_try == L2TP_MTRY_COUNT ) {
+  				info("l2tp: sccrq failed, fatal\n");
+  				iexit = 1;
+			} else {
+  				iret = l2tp_avp_build_req(pstate, AVP_MT_SCCRQ, &pdata);
+  			
+  				if( iret > 0 ) {
+  					l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  					l2tp_avp_free_pkt(&pdata);
+  					pstate->istage++;  				
+  				}	else {
+  					info("l2tp: build req error: %d, fatal\n", iret);
+  					iexit = 1;	
+  				}
+  			}
+  			break;
+  		case 1: /* wait SCCRP */
+  			while( (iread = l2tp_recv(pstate, &pdata, 10000)) > 0 ) {
+  				iret = l2tp_avp_parse_res(pstate, AVP_MT_SCCRP, pdata, (uint32_t)iread);
+  				l2tp_avp_free_pkt(&pdata);
+  				
+  				if( !iret ) {
+  					pstate->istage++;
+  					pstate->nr++;
+  					pstate->ns++;
+  					break;
+  				}
+  				}
+  				
+  			if( iread <= 0 ) {
+  				++pstate->ilast_try;
+  				info("l2tp: timeout of sccrp, retry sccrq, try: %d\n", pstate->ilast_try);
+				pstate->istage = 0;
+  			}
+  		
+  			break;
+  		case 2: /* send SCCCN */
+  			iret = l2tp_avp_build_req(pstate, AVP_MT_SCCCN, &pdata);
+
+  			if( iret > 0 ) {
+  				l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  				l2tp_avp_free_pkt(&pdata);  				
+  				pstate->istage++;  				
+  				pstate->ns++;
+  			} else {
+  				info("l2tp: build req error: %d, fatal\n", iret);
+  				iexit = 1;	
+  			}
+  			break;
+  		case 3: /* wait zlb */
+  			while( (iread = l2tp_recv(pstate, &pdata, 10000)) > 0 ) {
+  				iret = l2tp_avp_parse_res(pstate, 0xFF, pdata, (uint32_t)iread); /* zlb */
+  				l2tp_avp_free_pkt(&pdata);
+  				
+  				if( !iret ) {
+  					pstate->istage++;
+  					break;
+  				}
+  			} 
+  			
+  			if( iread <= 0 ) {
+  				info("l2tp: no ack, fatal\n");
+  				iexit = 1;
+  			}
+  		
+  			break;
+  		case 4: /* send icrq */
+  			iret = l2tp_avp_build_req(pstate, AVP_MT_ICRQ, &pdata);
+
+  			if( iret > 0 ) {
+  				l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  				l2tp_avp_free_pkt(&pdata);  				
+  				pstate->istage++;  				
+  				pstate->ns++;
+  			} else {
+  				info("l2tp: build req error: %d, fatal\n", iret);
+  				iexit = 1;	
+  			}
+  			break;
+  		case 5: /* wait icrp */
+  			while( (iread = l2tp_recv(pstate, &pdata, 10000)) > 0 ) {
+  				iret = l2tp_avp_parse_res(pstate, AVP_MT_ICRP, pdata, (uint32_t)iread);
+  				l2tp_avp_free_pkt(&pdata);
+  				
+				if( !iret ) {  				
+  					pstate->istage++;
+  					pstate->nr++;
+  					break;
+  				}
+  				}
+  				
+  			if( iread <= 0 ) {
+  				info("l2tp: no icrp, fatal\n");
+  				iexit = 1;
+  			}
+  			break;
+  		case 6: /* send ICCN */
+  			iret = l2tp_avp_build_req(pstate, AVP_MT_ICCN, &pdata);
+
+  			if( iret > 0 ) {
+  				l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  				l2tp_avp_free_pkt(&pdata);  				
+  				pstate->istage++;  				
+  				pstate->ns++;
+  			} else {
+  				info("l2tp: build req error: %d, fatal\n", iret);
+  				iexit = 1;	
+  			}
+  			break;
+  		case 7: /* wait zlb */
+  			while( (iread = l2tp_recv(pstate, &pdata, 10000)) > 0 ) {
+  				iret = l2tp_avp_parse_res(pstate, 0xFF, pdata, (uint32_t)iread); /* zlb */
+  				l2tp_avp_free_pkt(&pdata);
+  				
+  				if( !iret ) {
+  					pstate->istage++;
+  					if( l2tp_kernel_socket(pstate) < 0 ) {
+  						info("l2tp: failed to create kernel socket\n");
+  						iexit = 1;
+  					}
+  					break;
+  				}
+  				}
+  			
+  			if( iread <= 0 ) {
+  				info("l2tp: no ack, fatal\n");
+  				iexit = 1;
+  			}
+  		
+  			break;
+  		default:
+  			if( (iread = l2tp_recv(pstate, &pdata, 150)) > 0 ) { /* cdn, stopccn, hello handle */
+  				
+  				iret = l2tp_avp_parse_res(pstate, AVP_MT_HELLO, pdata, (uint32_t)iread); /* try hello parse */
+  				if( iret < 0 ) iret = l2tp_avp_parse_res(pstate, AVP_MT_CDN, pdata, (uint32_t)iread); /* try cdn parse */
+  				else if( iret == 0 ) iret = AVP_MT_HELLO;
+  				if( iret < 0 ) iret = l2tp_avp_parse_res(pstate, AVP_MT_STOPCCN, pdata, (uint32_t)iread); /* try stopccn parse */
+  				else if( iret == 0 ) iret = AVP_MT_CDN;
+  				if( !iret ) iret = AVP_MT_STOPCCN;
+  				
+  				l2tp_avp_free_pkt(&pdata);
+  				
+  				switch( iret ) {
+  				case AVP_MT_CDN:
+  				case AVP_MT_STOPCCN:
+  					iexit = 1;
+  				case AVP_MT_HELLO:
+  					pstate->nr = pstate->remns + 1; /* huge load drop override */
+  					iret = l2tp_avp_build_req(pstate, 0xFF, &pdata); /* zbl */
+  					if( iret > 0 ) {
+  						l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  						l2tp_avp_free_pkt(&pdata);  				
+  					}
+  					break;
+  				default:
+  					break;
+  				}
+  			}
+  			
+  			if( ++icnt >= 500 ) { /* average 1.5 min per hello */
+  				l2tp_sync_nsnr(pstate);
+  			
+  				icnt = 0;
+  				iret = l2tp_avp_build_req(pstate, AVP_MT_HELLO, &pdata);
+  				if( iret > 0 ) {
+  					l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  					l2tp_avp_free_pkt(&pdata);
+  					pstate->ns++; 
+  				}
+  			}
+  			break;
+  		}
+   }
+   
+  	l2tp_sync_nsnr(pstate);
+   
+   if( pstate->remsid ) {
+  		iret = l2tp_avp_build_req(pstate, AVP_MT_CDN, &pdata); /* cdn */
+  		if( iret > 0 ) {
+  			l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  			l2tp_avp_free_pkt(&pdata);  				
+  			pstate->ns++;
+  		}
+  	
+  		if( (iret = l2tp_recv(pstate, &pdata, 5000)) > 0 ) {
+  			l2tp_avp_free_pkt(&pdata);
+  		}
+  	}
+   
+   if( pstate->remtid ) {
+  		iret = l2tp_avp_build_req(pstate, AVP_MT_STOPCCN, &pdata); /* stopccn */
+  		if( iret > 0 ) {
+  			l2tp_send(pstate, pdata, (uint32_t)iret, 5000);
+  			l2tp_avp_free_pkt(&pdata);  				
+  			pstate->ns++;
+  		}
+  	
+  		if( (iret = l2tp_recv(pstate, &pdata, 5000)) > 0 ) {
+  			l2tp_avp_free_pkt(&pdata);
+  		}
+  	}
+		
+	close_socket(pstate->isock);   
+	
+	
+	return 0;
+}
+
+void on_term(int isig) {
+	iexit = 1;
+}
+
+int l2tp_main(const char *plns, pid_t parent_pid) {
+	PL2TP_STATE	pstate;
+	int iret;
+	
+	signal(SIGTERM, on_term);
+   signal(SIGINT, on_term);
+   signal(SIGHUP, on_term);
+	
+	info("l2tp_control v2.02\n");
+	
+	if( !(pstate = l2tp_init(plns, parent_pid)) ) {
+		info("l2tp: failed to init l2tp state\n");
+		goto error;
+	}
+	
+	if( (iret = l2tp_connect(pstate)) < 0 ) {
+		info("l2tp: failed to connect: %d\n", iret);
+		goto error_free;
+	}
+	
+error_free:
+	l2tp_free(&pstate);
+error:
+  kill(parent_pid, SIGHUP);
+	exit(0);
+	return 0;
+}
+
+int l2tp_wait_socket(pid_t fpid) {
+	int shmid, itry;
+	int flags;
+   struct sockaddr_pppol2tp sax;
+	PSHT psegptr = NULL;
+	SHT state;
+	
+	key = ftok("/dev/shm/l2tp", 'S');
+	
+	if( (shmid = shmget(key, sizeof(SHT), IPC_CREAT|IPC_EXCL|0666)) == -1 ) {
+  		if( (shmid = shmget(key, sizeof(SHT), 0)) == -1 ) {
+  			return -1;
+	  	}
+	}
+		 
+	if( (psegptr = (PSHT)shmat(shmid, 0, 0)) == (PSHT)-1 ) {
+     	shmctl(shmid, IPC_RMID, 0);
+		return -2;
+  	}
+	
+	psegptr->ifd = -1;
+	
+	itry = 0;
+   while( ++itry < 40 ) { /* average 20 sec */
+  		if( psegptr->ifd != -1 ) break;
+  		else 	usleep(500000);
+  	}
+  	
+  	memcpy(&state, psegptr, sizeof(SHT));
+  	shmdt(psegptr);	
+	shmctl(shmid, IPC_RMID, 0);
+  	
+  	if( state.ifd == -1 ) 
+		return -3;
+  	
+   if( (ikernel_sock = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OL2TP)) < 0 ) {
+		return -4;
+	}
+   
+   flags = fcntl(ikernel_sock, F_GETFL);
+   if( flags == -1 || fcntl(ikernel_sock, F_SETFL, flags | O_NONBLOCK) == -1 ) {
+		close(ikernel_sock);
+		ikernel_sock = -1;
+    	return -5;
+   }
+    
+   sax.sa_family = AF_PPPOX;
+   sax.sa_protocol = PX_PROTO_OL2TP;
+   sax.pppol2tp.pid = 0;
+   sax.pppol2tp.fd = state.ifd;
+   sax.pppol2tp.addr.sin_addr = state.addr;
+   sax.pppol2tp.addr.sin_port = L2TP_PORT;
+   sax.pppol2tp.addr.sin_family = AF_INET;
+   sax.pppol2tp.s_tunnel  = state.tid;
+   sax.pppol2tp.s_session = state.sid;
+   sax.pppol2tp.d_tunnel  = state.remtid;
+   sax.pppol2tp.d_session = state.remsid;
+
+   if( connect(ikernel_sock, (struct sockaddr *)&sax, sizeof(sax)) < 0 ) {
+		close(ikernel_sock);
+		ikernel_sock = -1;
+		return -6;
+   }
+	
+	return 0;
+}
+
+int l2tp_wait_exit(pid_t fpid) {
+	int iwaitstatus;
+	return waitpid(fpid, &iwaitstatus, 0);
+}
+
+int l2tp_control_init(const char *pppol2tp_lns) {
+	pid_t fpid;
+	
+	switch( (fpid = fork()) ) {
+   case -1: 
+		return -1;
+   case 0: 
+  		return l2tp_main(pppol2tp_lns, getppid());
+   default: 
+  		if( l2tp_wait_socket(fpid) < 0 ) {
+  			kill(fpid, SIGTERM);
+  			l2tp_wait_exit(fpid);
+  			return -1;
+  		} 		
+  		manager_pid = fpid;
+  		return 0;
+	}
+}
+
+int l2tp_control_get_socket() {
+	return ikernel_sock;
+}
+
+int l2tp_control_exit() {
+	if( manager_pid != -1 ) {
+		kill(manager_pid, SIGTERM);
+  		l2tp_wait_exit(manager_pid);
+  		manager_pid = -1;
+	}
+	return 0;
+}
+
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/l2tp.h ppp-2.4.4/pppd/plugins/pppol2tp/l2tp.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/l2tp.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/l2tp.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,242 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Protocol and implementation information,
- * structures and constants.
- */
-/*
-typedef unsigned short _u16;
-typedef unsigned long long _u64;
- */
-#ifndef _L2TP_H
-#define _L2TP_H
-
-#define MAXSTRLEN 120           /* Maximum length of common strings */
-
-#include <netinet/in.h>
-#include <termios.h>
-#include "osport.h"
-#include "scheduler.h"
-#include "misc.h"
-#include "file.h"
-#include "call.h"
-#include "avp.h"
-#include "control.h"
-#include "common.h"
-#include "ipsecmast.h"
-#include "aaa.h"
-
-#define BINARY "l2tp_plugin"
-#define SERVER_VERSION "xl2tpd-1.1.11-plugin-0.1"
-#define VENDOR_NAME "xelerance.com"
-#define FIRMWARE_REV	0x0690  /* Revision of our firmware (software, in this case) */
-#define DEF_MAX_TUNNELS 1      /* By default only allow this many
-                                   tunnels to exist */
-
-#define HELLO_DELAY 60          /* How often to send a Hello message */
-
-struct control_hdr
-{
-    _u16 ver;                   /* Version and more */
-    _u16 length;                /* Length field */
-    _u16 tid;                   /* Tunnel ID */
-    _u16 cid;                   /* Call ID */
-    _u16 Ns;                    /* Next sent */
-    _u16 Nr;                    /* Next received */
-} __attribute__((packed));
-
-#define CTBIT(ver) (ver & 0x8000)       /* Determins if control or not */
-#define CLBIT(ver) (ver & 0x4000)       /* Length bit present.  Must be 1
-                                           for control messages */
-
-#define CZBITS(ver) (ver &0x37F8)       /* Reserved bits:  We must drop 
-                                           anything with these there */
-
-#define CFBIT(ver) (ver & 0x0800)       /* Presence of Ns and Nr fields
-                                           flow bit? */
-
-#define CVER(ver) (ver & 0x0007)        /* Version of encapsulation */
-
-
-struct payload_hdr
-{
-    _u16 ver;                   /* Version and friends */
-    _u16 length;                /* Optional Length */
-    _u16 tid;                   /* Tunnel ID */
-    _u16 cid;                   /* Caller ID */
-    _u16 Ns;                    /* Optional next sent */
-    _u16 Nr;                    /* Optional next received */
-    _u16 o_size;                /* Optional offset size */
-    _u16 o_pad;                 /* Optional offset padding */
-} __attribute__((packed));
-
-#define NZL_TIMEOUT_DIVISOR 4   /* Divide TIMEOUT by this and
-                                   you know how often to send
-                                   a zero byte packet */
-
-#define PAYLOAD_BUF 10          /* Provide 10 expansion bytes
-                                   so we can "decompress" the
-                                   payloads and simplify coding */
-#if 1
-#define DEFAULT_MAX_RETRIES 10    /* Recommended value from spec */
-#else
-#define DEFAULT_MAX_RETRIES 95   /* give us more time to debug */
-#endif
-
-#define DEFAULT_RWS_SIZE   4    /* Default max outstanding 
-                                   control packets in queue */
-#define DEFAULT_TX_BPS		10000000        /* For outgoing calls, report this speed */
-#define DEFAULT_RX_BPS		10000000
-#define DEFAULT_MAX_BPS		10000000        /* jz: outgoing calls max bps */
-#define DEFAULT_MIN_BPS		10000   /* jz: outgoing calls min bps */
-#define PAYLOAD_FUDGE		2       /* How many packets we're willing to drop */
-#define MIN_PAYLOAD_HDR_LEN 6
-
-#define UDP_LISTEN_PORT  1701
-                                /* FIXME: MAX_RECV_SIZE, what is it? */
-#define MAX_RECV_SIZE 4096      /* Biggest packet we'll accept */
-
-#define OUR_L2TP_VERSION 0x100  /* We support version 1, revision 0 */
-
-#define PTBIT(ver) CTBIT(ver)   /* Type bit:  Must be zero for us */
-#define PLBIT(ver) CLBIT(ver)   /* Length specified? */
-#define PFBIT(ver) CFBIT(ver)   /* Flow control specified? */
-#define PVER(ver) CVER(ver)     /* Version */
-#define PZBITS(ver) (ver & 0x14F8)      /* Reserved bits */
-#define PRBIT(ver) (ver & 0x2000)       /* Reset Sr bit */
-#define PSBIT(ver) (ver & 0x0200)       /* Offset size bit */
-#define PPBIT(ver) (ver & 0x0100)       /* Preference bit */
-
-struct tunnel
-{
-    struct call *call_head;     /* Member calls */
-    struct tunnel *next;        /* Allows us to be linked easily */
-
-    int fc;                     /* Framing capabilities of peer */
-    struct schedule_entry *hello;
-    int ourfc;                  /* Our framing capabilities */
-    int bc;                     /* Peer's bearer channels */
-    int hbit;                   /* Allow hidden AVP's? */
-    int ourbc;                  /* Our bearer channels */
-    _u64 tb;                    /* Their tie breaker */
-    _u64 ourtb;                 /* Our tie breaker */
-    int tid;                    /* Peer's tunnel identifier */
-    IPsecSAref_t refme;         /* IPsec SA particulars */
-    IPsecSAref_t refhim;
-    int ourtid;                 /* Our tunnel identifier */
-    int qtid;                   /* TID for disconnection */
-    int firmware;               /* Peer's firmware revision */
-#if 0
-    unsigned int addr;          /* Remote address */
-    unsigned short port;        /* Port on remote end */
-#else
-    struct sockaddr_in peer;    /* Peer's Address */
-#endif
-    int debug;                  /* Are we debugging or not? */
-    int nego;                   /* Show Negotiation? */
-    int count;
-    int state;                  /* State of tunnel */
-    _u16 control_seq_num;       /* Sequence for next packet */
-    _u16 control_rec_seq_num;   /* Next expected to receive */
-    int cLr;                    /* Last packet received by peer */
-    char hostname[MAXSTRLEN];   /* Remote hostname */
-    char vendor[MAXSTRLEN];     /* Vendor of remote product */
-    struct challenge chal_us;   /* Their Challenge to us */
-    struct challenge chal_them; /* Our challenge to them */
-    char secret[MAXSTRLEN];     /* Secret to use */
-#ifdef SANITY
-    int sanity;                 /* check for sanity? */
-#endif
-    int rws;                    /* Peer's Receive Window Size */
-    int ourrws;                 /* Receive Window Size */
-    struct call *self;
-    struct lac *lac;            /* LAC that owns us */
-};
-
-struct tunnel_list
-{
-    struct tunnel *head;
-    int count;
-    int calls;
-};
-
-/* Values for version */
-#define VER_L2TP 2
-#define VER_PPTP 3
-
-/* Some PPP sync<->async stuff */
-#define fcstab  ppp_crc16_table
-
-#define PPP_FLAG 0x7e
-#define PPP_ESCAPE 0x7d
-#define PPP_TRANS 0x20
-
-#define PPP_INITFCS 0xffff
-#define PPP_GOODFCS 0xf0b8
-#define PPP_FCS(fcs,c) (((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])
-
-/* Values for Randomness sources */
-#define RAND_DEV 0x0
-#define RAND_SYS 0x1
-#define RAND_EGD 0x2
-
-
-/* Error Values */
-
-extern struct tunnel_list tunnels;
-extern void tunnel_close (struct tunnel *t);
-extern void network_thread ();
-extern int init_network ();
-extern void close_network ();
-extern int max_tunnels;
-extern int server_socket; 
-extern struct tunnel *new_tunnel ();
-extern struct packet_queue xmit_udp;
-extern void destroy_tunnel (struct tunnel *);
-extern struct buffer *new_payload (struct sockaddr_in);
-extern void recycle_payload (struct buffer *, struct sockaddr_in);
-extern void add_payload_hdr (struct tunnel *, struct call *, struct buffer *);
-extern int call_read_packet (struct buffer *, int, int);
-extern void udp_xmit (struct buffer *buf, struct tunnel *t);
-extern void control_xmit (void *);
-extern int ppd;
-extern int iexit;
-extern void start_pppd (struct call *c);
-extern void stop_pppd(int istat);
-extern void magic_lac_dial (void *);
-extern int get_entropy (unsigned char *, int);
-
-#ifndef MIN
-#define MIN(a,b) (((a)<(b)) ? (a) : (b))
-#endif
-#endif
-
-static inline void *zalloc(int isize) {
-    void *pdata;
-    if( (pdata = malloc(isize)) ) memset(pdata, 0, isize);
-    else exit(-111);
-    return pdata;
-}
-
-extern void l2tp_wait_socket();
-extern int l2tp_get_socket();
-extern int l2tp_init(char *lns);
-extern void l2tp_exit();
-
-/* 
- * This is just some stuff to take
- * care of kernel definitions
- */
-
-#include <net/if.h>
-#include <linux/if_ether.h>
-#include <linux/if_pppox.h>
-#include <linux/if_pppol2tp.h>
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/Makefile.linux ppp-2.4.4/pppd/plugins/pppol2tp/Makefile.linux
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/Makefile.linux	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/Makefile.linux	2013-01-17 16:41:07.307156058 +0400
@@ -31,7 +31,7 @@
 include .depend
 endif
 
-pppol2tp.so: l2tp.o xl2tpd.o misc.o control.o avp.o call.o network.o avpsend.o scheduler.o file.o aaa.o md5.o
+pppol2tp.so: l2tp.o l2tp_control.o avp.o 
 	$(CC) -o $@ $(LDFLAGS) $^
 	cp pppol2tp.so libpppol2tp.so
 
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/md5.c ppp-2.4.4/pppd/plugins/pppol2tp/md5.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/md5.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/md5.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,272 +0,0 @@
-#ifdef FREEBSD
-# include <machine/endian.h>
-#elif defined(LINUX)
-# include <endian.h>
-#elif defined(SOLARIS)
-# include <sys/isa_defs.h>
-#endif
-#if __BYTE_ORDER == __BIG_ENDIAN
-#define HIGHFIRST 1
-#endif
-
-/*
- * This code implements the MD5 message-digest algorithm.
- * The algorithm is due to Ron Rivest.  This code was
- * written by Colin Plumb in 1993, no copyright is claimed.
- * This code is in the public domain; do with it what you wish.
- *
- * Equivalent code is available from RSA Data Security, Inc.
- * This code has been tested against that, and is equivalent,
- * except that you don't need to include two pages of legalese
- * with every copy.
- *
- * To compute the message digest of a chunk of bytes, declare an
- * MD5Context structure, pass it to MD5Init, call MD5Update as
- * needed on buffers full of bytes, and then call MD5Final, which
- * will fill a supplied 16-byte array with the digest.
- */
-#include <string.h>             /* for memcpy() */
-#include "md5.h"
-
-#ifndef HIGHFIRST
-#define byteReverse(buf, len)   /* Nothing */
-#else
-void byteReverse (unsigned char *buf, unsigned longs);
-
-#ifndef ASM_MD5
-/*
- * Note: this code is harmless on little-endian machines.
- */
-void byteReverse (unsigned char *buf, unsigned longs)
-{
-    uint32 t;
-    do
-    {
-        t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
-            ((unsigned) buf[1] << 8 | buf[0]);
-        *(uint32 *) buf = t;
-        buf += 4;
-    }
-    while (--longs);
-}
-#endif
-#endif
-
-/*
- * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
- * initialization constants.
- */
-void MD5Init (struct MD5Context *ctx)
-{
-    ctx->buf[0] = 0x67452301;
-    ctx->buf[1] = 0xefcdab89;
-    ctx->buf[2] = 0x98badcfe;
-    ctx->buf[3] = 0x10325476;
-
-    ctx->bits[0] = 0;
-    ctx->bits[1] = 0;
-}
-
-/*
- * Update context to reflect the concatenation of another buffer full
- * of bytes.
- */
-void MD5Update (struct MD5Context *ctx, unsigned char const *buf,
-                unsigned len)
-{
-    uint32 t;
-
-    /* Update bitcount */
-
-    t = ctx->bits[0];
-    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
-        ctx->bits[1]++;         /* Carry from low to high */
-    ctx->bits[1] += len >> 29;
-
-    t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */
-
-    /* Handle any leading odd-sized chunks */
-
-    if (t)
-    {
-        unsigned char *p = (unsigned char *) ctx->in + t;
-
-        t = 64 - t;
-        if (len < t)
-        {
-            memcpy (p, buf, len);
-            return;
-        }
-        memcpy (p, buf, t);
-        byteReverse (ctx->in, 16);
-        MD5Transform (ctx->buf, (uint32 *) ctx->in);
-        buf += t;
-        len -= t;
-    }
-    /* Process data in 64-byte chunks */
-
-    while (len >= 64)
-    {
-        memcpy (ctx->in, buf, 64);
-        byteReverse (ctx->in, 16);
-        MD5Transform (ctx->buf, (uint32 *) ctx->in);
-        buf += 64;
-        len -= 64;
-    }
-
-    /* Handle any remaining bytes of data. */
-
-    memcpy (ctx->in, buf, len);
-}
-
-/*
- * Final wrapup - pad to 64-byte boundary with the bit pattern 
- * 1 0* (64-bit count of bits processed, MSB-first)
- */
-void MD5Final (unsigned char digest[16], struct MD5Context *ctx)
-{
-    unsigned count;
-    unsigned char *p;
-
-    /* Compute number of bytes mod 64 */
-    count = (ctx->bits[0] >> 3) & 0x3F;
-
-    /* Set the first char of padding to 0x80.  This is safe since there is
-       always at least one byte free */
-    p = ctx->in + count;
-    *p++ = 0x80;
-
-    /* Bytes of padding needed to make 64 bytes */
-    count = 64 - 1 - count;
-
-    /* Pad out to 56 mod 64 */
-    if (count < 8)
-    {
-        /* Two lots of padding:  Pad the first block to 64 bytes */
-        memset (p, 0, count);
-        byteReverse (ctx->in, 16);
-        MD5Transform (ctx->buf, (uint32 *) ctx->in);
-
-        /* Now fill the next block with 56 bytes */
-        memset (ctx->in, 0, 56);
-    }
-    else
-    {
-        /* Pad block to 56 bytes */
-        memset (p, 0, count - 8);
-    }
-    byteReverse (ctx->in, 14);
-
-    /* Append length in bits and transform */
-    ((uint32 *) ctx->in)[14] = ctx->bits[0];
-    ((uint32 *) ctx->in)[15] = ctx->bits[1];
-
-    MD5Transform (ctx->buf, (uint32 *) ctx->in);
-    byteReverse ((unsigned char *) ctx->buf, 4);
-    memcpy (digest, ctx->buf, 16);
-    memset (ctx, 0, sizeof (ctx));      /* In case it's sensitive */
-}
-
-#ifndef ASM_MD5
-
-/* The four core functions - F1 is optimized somewhat */
-
-/* #define F1(x, y, z) (x & y | ~x & z) */
-#define F1(x, y, z) (z ^ (x & (y ^ z)))
-#define F2(x, y, z) F1(z, x, y)
-#define F3(x, y, z) (x ^ y ^ z)
-#define F4(x, y, z) (y ^ (x | ~z))
-
-/* This is the central step in the MD5 algorithm. */
-#define MD5STEP(f, w, x, y, z, data, s) \
-	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
-
-/*
- * The core of the MD5 algorithm, this alters an existing MD5 hash to
- * reflect the addition of 16 longwords of new data.  MD5Update blocks
- * the data and converts bytes into longwords for this routine.
- */
-void MD5Transform (uint32 buf[4], uint32 const in[16])
-{
-    register uint32 a, b, c, d;
-
-    a = buf[0];
-    b = buf[1];
-    c = buf[2];
-    d = buf[3];
-
-    MD5STEP (F1, a, b, c, d, in[0] + 0xd76aa478, 7);
-    MD5STEP (F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
-    MD5STEP (F1, c, d, a, b, in[2] + 0x242070db, 17);
-    MD5STEP (F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
-    MD5STEP (F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
-    MD5STEP (F1, d, a, b, c, in[5] + 0x4787c62a, 12);
-    MD5STEP (F1, c, d, a, b, in[6] + 0xa8304613, 17);
-    MD5STEP (F1, b, c, d, a, in[7] + 0xfd469501, 22);
-    MD5STEP (F1, a, b, c, d, in[8] + 0x698098d8, 7);
-    MD5STEP (F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
-    MD5STEP (F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
-    MD5STEP (F1, b, c, d, a, in[11] + 0x895cd7be, 22);
-    MD5STEP (F1, a, b, c, d, in[12] + 0x6b901122, 7);
-    MD5STEP (F1, d, a, b, c, in[13] + 0xfd987193, 12);
-    MD5STEP (F1, c, d, a, b, in[14] + 0xa679438e, 17);
-    MD5STEP (F1, b, c, d, a, in[15] + 0x49b40821, 22);
-
-    MD5STEP (F2, a, b, c, d, in[1] + 0xf61e2562, 5);
-    MD5STEP (F2, d, a, b, c, in[6] + 0xc040b340, 9);
-    MD5STEP (F2, c, d, a, b, in[11] + 0x265e5a51, 14);
-    MD5STEP (F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
-    MD5STEP (F2, a, b, c, d, in[5] + 0xd62f105d, 5);
-    MD5STEP (F2, d, a, b, c, in[10] + 0x02441453, 9);
-    MD5STEP (F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
-    MD5STEP (F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
-    MD5STEP (F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
-    MD5STEP (F2, d, a, b, c, in[14] + 0xc33707d6, 9);
-    MD5STEP (F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
-    MD5STEP (F2, b, c, d, a, in[8] + 0x455a14ed, 20);
-    MD5STEP (F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
-    MD5STEP (F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
-    MD5STEP (F2, c, d, a, b, in[7] + 0x676f02d9, 14);
-    MD5STEP (F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
-
-    MD5STEP (F3, a, b, c, d, in[5] + 0xfffa3942, 4);
-    MD5STEP (F3, d, a, b, c, in[8] + 0x8771f681, 11);
-    MD5STEP (F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
-    MD5STEP (F3, b, c, d, a, in[14] + 0xfde5380c, 23);
-    MD5STEP (F3, a, b, c, d, in[1] + 0xa4beea44, 4);
-    MD5STEP (F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
-    MD5STEP (F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
-    MD5STEP (F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
-    MD5STEP (F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
-    MD5STEP (F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
-    MD5STEP (F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
-    MD5STEP (F3, b, c, d, a, in[6] + 0x04881d05, 23);
-    MD5STEP (F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
-    MD5STEP (F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
-    MD5STEP (F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
-    MD5STEP (F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
-
-    MD5STEP (F4, a, b, c, d, in[0] + 0xf4292244, 6);
-    MD5STEP (F4, d, a, b, c, in[7] + 0x432aff97, 10);
-    MD5STEP (F4, c, d, a, b, in[14] + 0xab9423a7, 15);
-    MD5STEP (F4, b, c, d, a, in[5] + 0xfc93a039, 21);
-    MD5STEP (F4, a, b, c, d, in[12] + 0x655b59c3, 6);
-    MD5STEP (F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
-    MD5STEP (F4, c, d, a, b, in[10] + 0xffeff47d, 15);
-    MD5STEP (F4, b, c, d, a, in[1] + 0x85845dd1, 21);
-    MD5STEP (F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
-    MD5STEP (F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
-    MD5STEP (F4, c, d, a, b, in[6] + 0xa3014314, 15);
-    MD5STEP (F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
-    MD5STEP (F4, a, b, c, d, in[4] + 0xf7537e82, 6);
-    MD5STEP (F4, d, a, b, c, in[11] + 0xbd3af235, 10);
-    MD5STEP (F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
-    MD5STEP (F4, b, c, d, a, in[9] + 0xeb86d391, 21);
-
-    buf[0] += a;
-    buf[1] += b;
-    buf[2] += c;
-    buf[3] += d;
-}
-
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/md5.h ppp-2.4.4/pppd/plugins/pppol2tp/md5.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/md5.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/md5.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,28 +0,0 @@
-#ifndef MD5_H
-#define MD5_H
-
-#ifdef __alpha
-typedef unsigned int uint32;
-#else
-typedef unsigned long uint32;
-#endif
-
-struct MD5Context
-{
-    uint32 buf[4];
-    uint32 bits[2];
-    unsigned char in[64];
-};
-
-void MD5Init (struct MD5Context *context);
-void MD5Update (struct MD5Context *context, unsigned char const *buf,
-                unsigned len);
-void MD5Final (unsigned char digest[16], struct MD5Context *context);
-void MD5Transform (uint32 buf[4], uint32 const in[16]);
-
-/*
- * This is needed to make RSAREF happy on some MS-DOS compilers.
- */
-typedef struct MD5Context MD5_CTX;
-
-#endif /* !MD5_H */
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/misc.c ppp-2.4.4/pppd/plugins/pppol2tp/misc.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/misc.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/misc.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,274 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Miscellaneous but important functions
- *
- */
-
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <string.h>
-#include <syslog.h>
-#if defined(SOLARIS)
-# include <varargs.h>
-#endif
-#include <netinet/in.h>
-#include "l2tp.h"
-
-void init_log()
-{
-    static int logopen=0;
-    
-    if(!logopen) {
-	openlog (BINARY, LOG_PID, LOG_DAEMON);
-    }
-}
-
-void l2tp_log (int level, const char *fmt, ...)
-{
-    char buf[256];
-    va_list args;
-    va_start (args, fmt);
-    vsnprintf (buf, sizeof (buf), fmt, args);
-    va_end (args);
-    
-    init_log();
-    syslog (level, "%s", buf);
-    /* printf(buf); */
-}
-
-void set_error (struct call *c, int error, const char *fmt, ...)
-{
-    va_list args;
-    va_start (args, fmt);
-    c->error = error;
-    c->result = RESULT_ERROR;
-    c->needclose = -1;
-    vsnprintf (c->errormsg, sizeof (c->errormsg), fmt, args);
-    if (c->errormsg[strlen (c->errormsg) - 1] == '\n')
-        c->errormsg[strlen (c->errormsg) - 1] = 0;
-    va_end (args);
-}
-
-struct buffer *new_buf (int size)
-{
-    struct buffer *b = zalloc (sizeof (struct buffer));
-
-    if (!b || !size || size < 0)
-        return NULL;
-    b->rstart = zalloc (size);
-    if (!b->rstart)
-    {
-        free (b);
-        return NULL;
-    }
-    b->start = b->rstart;
-    b->rend = b->rstart + size - 1;
-    b->len = size;
-    b->maxlen = size;
-    return b;
-}
-
-inline void recycle_buf (struct buffer *b)
-{
-    b->start = b->rstart;
-    b->len = b->maxlen;
-}
-
-#define bufferDumpWIDTH 16
-void bufferDump (unsigned char *buf, int buflen)
-{
-    int i = 0, j = 0;
-    /* we need TWO characters to DISPLAY ONE byte */
-    char line[2 * bufferDumpWIDTH + 1], *c;
-
-    for (i = 0; i < buflen / bufferDumpWIDTH; i++)
-    {
-        c = line;
-        for (j = 0; j < bufferDumpWIDTH; j++)
-        {
-	  sprintf (c, "%02x ", (buf[i * bufferDumpWIDTH + j]) & 0xff);
-            c++;
-            c++;                /* again two characters to display ONE byte */
-        }
-        *c = '\0';
-        l2tp_log (LOG_WARNING,
-		  "%s: buflen=%d, buffer[%d]: *%s*\n", __FUNCTION__,
-		  buflen, i, line);
-    }
-
-    c = line;
-    for (j = 0; j < buflen % bufferDumpWIDTH; j++)
-    {
-        sprintf (c, "%02x ",
-                 buf[(buflen / bufferDumpWIDTH) * bufferDumpWIDTH +
-                     j] & 0xff);
-        c++;
-        c++;
-    }
-    if (c != line)
-    {
-        *c = '\0';
-        l2tp_log (LOG_WARNING,
-		  "%s:             buffer[%d]: *%s*\n", __FUNCTION__, i,
-		  line);
-    }
-}
-
-void do_packet_dump (struct buffer *buf)
-{
-    int x;
-    unsigned char *c = buf->start;
-    printf ("packet dump: \nHEX: { ");
-    for (x = 0; x < buf->len; x++)
-    {
-        printf ("%.2X ", *c);
-        c++;
-    };
-    printf ("}\nASCII: { ");
-    c = buf->start;
-    for (x = 0; x < buf->len; x++)
-    {
-        if (*c > 31 && *c < 127)
-        {
-            putchar (*c);
-        }
-        else
-        {
-            putchar (' ');
-        }
-        c++;
-    }
-    printf ("}\n");
-}
-
-inline void swaps (void *buf_v, int len)
-{
-#ifdef __alpha
-    /* Reverse byte order alpha is little endian so lest save a step.
-       to make things work out easier */
-    int x;
-    unsigned char t1;
-    unsigned char *tmp = (_u16 *) buf_v;
-    for (x = 0; x < len; x += 2)
-    {
-        t1 = tmp[x];
-        tmp[x] = tmp[x + 1];
-        tmp[x + 1] = t1;
-    }
-#else
-
-    /* Reverse byte order (if proper to do so) 
-       to make things work out easier */
-    int x;
-	struct hw { _u16 s; } __attribute__ ((packed)) *p = (struct hw *) buf_v;
-	for (x = 0; x < len / 2; x++, p++)
-		p->s = ntohs(p->s); 
-#endif
-}
-
-
-
-inline void toss (struct buffer *buf)
-{
-    /*
-     * Toss a frame and free up the buffer that contained it
-     */
-
-    free (buf->rstart);
-    free (buf);
-}
-
-inline void safe_copy (char *a, char *b, int size)
-{
-    /* Copies B into A (assuming A holds MAXSTRLEN bytes)
-       safely */
-    strncpy (a, b, MIN (size, MAXSTRLEN - 1));
-    a[MIN (size, MAXSTRLEN - 1)] = '\000';
-}
-
-int get_egd_entropy(char *buf, int count)
-{
-    return -1;
-}
-
-int get_sys_entropy(unsigned char *buf, int count)
-{
-    /*
-     * This way of filling buf with rand() generated data is really
-     * fairly inefficient from a function call point of view...rand()
-     * returns four bytes of data (on most systems, sizeof(int))
-     * and we end up only using 1 byte of it (sizeof(char))...ah
-     * well...it was a *whole* lot easier to code this way...suggestions
-     * for improvements are, of course, welcome
-     */
-    int counter;
-    for (counter = 0; counter < count; counter++)
-    {
-        buf[counter] = (char)rand();
-    }
-#ifdef DEBUG_ENTROPY
-    bufferDump (buf, count);
-#endif
-    return count;
-}
-
-int get_dev_entropy(unsigned char *buf, int count)
-{
-    int devrandom;
-    ssize_t entropy_amount;
-
-    devrandom = open ("/dev/urandom", O_RDONLY | O_NONBLOCK);
-    if (devrandom == -1)
-    {
-#ifdef DEBUG_ENTROPY
-        l2tp_log(LOG_WARNING, "%s: couldn't open /dev/urandom,"
-                      "falling back to rand()\n",
-                      __FUNCTION__);
-#endif
-        return get_sys_entropy(buf, count);
-    }
-    entropy_amount = read(devrandom, buf, count);
-    close(devrandom);
-    return entropy_amount;
-}
-
-int get_entropy (unsigned char *buf, int count)
-{
-    if (rand_source == RAND_SYS)
-    {
-        return get_sys_entropy(buf, count);
-    }
-    else if (rand_source == RAND_DEV)
-    {
-        return get_dev_entropy(buf, count);
-    }
-    else if (rand_source == RAND_EGD)
-    {
-        l2tp_log(LOG_WARNING,
-		 "%s: EGD Randomness source not yet implemented\n",
-                __FUNCTION__);
-        return -1;
-    }
-    else
-    {
-	    l2tp_log(LOG_WARNING,
-		     "%s: Invalid Randomness source specified (%d)\n",
-		     __FUNCTION__, rand_source);
-	    return -1;
-    }
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/misc.h ppp-2.4.4/pppd/plugins/pppol2tp/misc.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/misc.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/misc.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,68 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Misc stuff...
- */
-
-#ifndef _MISC_H
-#define _MISC_H
-
-#include <syslog.h>
-
-struct tunnel;
-struct buffer
-{
-    int type;
-    void *rstart;
-    void *rend;
-    void *start;
-    int len;
-    int maxlen;
-#if 0
-    unsigned int addr;
-    int port;
-#else
-    struct sockaddr_in peer;
-#endif
-    struct tunnel *tunnel;      /* Who owns this packet, if it's a control */
-    int retries;                /* Again, if a control packet, how many retries? */
-};
-
-#define IPADDY(a) inet_ntoa(*((struct in_addr *)&(a)))
-
-//#define DEBUG c ? c->debug || t->debug : t->debug
-#define DEBUG 0
-
-#ifdef USE_SWAPS_INSTEAD
-#define SWAPS(a) ((((a) & 0xFF) << 8 ) | (((a) >> 8) & 0xFF))
-#ifdef htons
-#undef htons
-#endif
-#ifdef ntohs
-#undef htons
-#endif
-#define htons(a) SWAPS(a)
-#define ntohs(a) SWAPS(a)
-#endif
-
-#define halt() printf("Halted.\n") ; for(;;)
-
-extern char hostname[];
-extern void l2tp_log (int level, const char *fmt, ...);
-extern struct buffer *new_buf (int);
-extern void udppush_handler (int);
-extern int addfcs (struct buffer *buf);
-extern inline void swaps (void *, int);
-extern void do_packet_dump (struct buffer *);
-extern int getPtyMaster(char *, int);
-extern void recycle_buf (struct buffer *);
-extern void safe_copy (char *, char *, int);
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/network.c ppp-2.4.4/pppd/plugins/pppol2tp/network.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/network.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/network.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,596 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Network routines for UDP handling
- */
-#include <stdio.h>
-#include <errno.h>
-#include <string.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <sys/ioctl.h>
-#include "l2tp.h"
-#include "ipsecmast.h"
-#include <signal.h>
-
-char hostname[256];
-struct sockaddr_in server, from;        /* Server and transmitter structs */
-int server_socket = -1;              /* Server socket */
-
-int init_network (void)
-{
-    long arg;
-    unsigned int length = sizeof (server);
-    gethostname (hostname, sizeof (hostname));
-    server.sin_family = AF_INET;
-    server.sin_addr.s_addr = gconfig.listenaddr; 
-    server.sin_port = htons (gconfig.port);
-    if ((server_socket = socket (PF_INET, SOCK_DGRAM, 0)) < 0)
-    {
-        l2tp_log (LOG_CRIT, "%s: Unable to allocate socket. Terminating.\n",
-             __FUNCTION__);
-        return -EINVAL;
-    };
-
-    arg = 1; 
-    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &arg, sizeof(arg));
-    /* continue on error */
-    
-    if (bind (server_socket, (struct sockaddr *) &server, sizeof (server)))
-    {
-        close (server_socket);
-        server_socket = -1;
-        l2tp_log (LOG_CRIT, "%s: Unable to bind socket: %s. Terminating.\n",
-             __FUNCTION__, strerror(errno), errno);
-        return -EINVAL;
-    };
-    
-    if (getsockname (server_socket, (struct sockaddr *) &server, &length))
-    {
-        l2tp_log (LOG_CRIT, "%s: Unable to read socket name.Terminating.\n",
-             __FUNCTION__);
-	close(server_socket);
-	server_socket = -1;
-        return -EINVAL;
-    }
-    /*
-     * For L2TP/IPsec with KLIPSng, set the socket to receive IPsec REFINFO
-     * values.
-     */
-    arg=1;
-    if(setsockopt(server_socket, SOL_IP, IP_IPSEC_REFINFO,
-		  &arg, sizeof(arg)) != 0) {
-	    l2tp_log(LOG_CRIT, "setsockopt recvref: %s\n", strerror(errno));
-
-	    gconfig.ipsecsaref=0;
-    }
-    
-    arg = fcntl (server_socket, F_GETFL);
-    arg |= O_NONBLOCK;
-    fcntl (server_socket, F_SETFL, arg);
-    gconfig.port = ntohs (server.sin_port);
-    return 0;
-}
-
-void close_network() {
-    if( server_socket != -1 ) {    
-	close(server_socket);
-	server_socket = -1;
-    }
-}
-
-inline void extract (void *buf, int *tunnel, int *call)
-{
-    /*
-     * Extract the tunnel and call #'s, and fix the order of the 
-     * version
-     */
-
-    struct payload_hdr *p = (struct payload_hdr *) buf;
-    if (PLBIT (p->ver))
-    {
-        *tunnel = p->tid;
-        *call = p->cid;
-    }
-    else
-    {
-        *tunnel = p->length;
-        *call = p->tid;
-    }
-}
-
-inline void fix_hdr (void *buf)
-{
-    /*
-     * Fix the byte order of the header
-     */
-
-    struct payload_hdr *p = (struct payload_hdr *) buf;
-    _u16 ver = ntohs (p->ver);
-    if (CTBIT (p->ver))
-    {
-        /*
-         * Control headers are always
-         * exactly 12 bytes big.
-         */
-        swaps (buf, 12);
-    }
-    else
-    {
-        int len = 6;
-        if (PSBIT (ver))
-            len += 4;
-        if (PLBIT (ver))
-            len += 2;
-        if (PFBIT (ver))
-            len += 4;
-        swaps (buf, len);
-    }
-}
-
-void dethrottle (void *call)
-{
-/*	struct call *c = (struct call *)call; */
-/*	if (c->throttle) {
-#ifdef DEBUG_FLOW
-		log(LOG_DEBUG, "%s: dethrottling call %d, and setting R-bit\n",__FUNCTION__,c->ourcid); 
-#endif 		c->rbit = RBIT;
-		c->throttle = 0;
-	} else {
-		log(LOG_DEBUG, "%s:  call %d already dethrottled?\n",__FUNCTION__,c->ourcid); 	
-	} */
-}
-
-void control_xmit (void *b)
-{
-    struct buffer *buf = (struct buffer *) b;
-    struct tunnel *t;
-    struct timeval tv;
-    int ns;
-
-    if (!buf)
-    {
-        l2tp_log (LOG_WARNING, "%s: called on NULL buffer!\n", __FUNCTION__);
-        return;
-    }
-
-    t = buf->tunnel;
-#ifdef DEBUG_CONTROL_XMIT
-    if(t) {
-	    l2tp_log (LOG_NOTICE,
-		      "trying to send control packet to %d / %d\n",
-		      t->ourtid, buf->retries);
-    }
-#endif
-
-    buf->retries++;
-    ns = ntohs (((struct control_hdr *) (buf->start))->Ns);
-    if (t)
-    {
-        if (ns < t->cLr)
-        {
-#ifdef DEBUG_CONTROL_XMIT
-            l2tp_log (LOG_NOTICE, "%s: Tossing packet %d\n", __FUNCTION__, ns);
-#endif
-            /* Okay, it's been received.  Let's toss it now */
-            toss (buf);
-            return;
-        }
-    }
-    if (buf->retries > DEFAULT_MAX_RETRIES)
-    {
-        /*
-           * Too many retries.  Either kill the tunnel, or
-           * if there is no tunnel, just stop retransmitting.
-         */
-        if (t)
-        {
-            if (t->self->needclose)
-            {
-                l2tp_log (LOG_DEBUG,
-                     "Unable to deliver closing message for tunnel %d. Destroying anyway.\n",
-                     t->ourtid);
-                t->self->needclose = 0;
-                t->self->closing = -1;
-            }
-            else
-            {
-                l2tp_log (LOG_NOTICE,
-                     "Maximum retries exceeded for tunnel %d.  Closing.\n",
-                     t->ourtid);
-                strcpy (t->self->errormsg, "Timeout");
-                t->self->needclose = -1;
-            }
-        }
-	free(buf->rstart);
-	free(buf);
-	stop_pppd(3);
-    } 
-    else
-    {
-        /*
-           * FIXME:  How about adaptive timeouts?
-         */
-        tv.tv_sec = 1;
-        tv.tv_usec = 0;
-        schedule (tv, control_xmit, buf);
-#ifdef DEBUG_CONTROL_XMIT
-        l2tp_log (LOG_DEBUG, "%s: Scheduling and transmitting packet %d\n",
-             __FUNCTION__, ns);
-#endif
-        udp_xmit (buf, t);
-    }
-}
-
-void udp_xmit (struct buffer *buf, struct tunnel *t)
-{
-    struct cmsghdr *cmsg;
-    char cbuf[CMSG_SPACE(sizeof (unsigned int))];
-    unsigned int *refp;
-    struct msghdr msgh;
-    int err;
-    struct iovec iov;
-    
-    if( !t ) return;
-    
-    /*
-     * OKAY, now send a packet with the right SAref values.
-     */
-    memset(&msgh, 0, sizeof(struct msghdr));
-    
-    msgh.msg_control = cbuf;
-    msgh.msg_controllen = 0;
-
-    if(gconfig.ipsecsaref && t->refhim != IPSEC_SAREF_NULL) {
-	msgh.msg_controllen = sizeof(cbuf);
-
-	cmsg = CMSG_FIRSTHDR(&msgh);
-	cmsg->cmsg_level = SOL_IP;
-	cmsg->cmsg_type  = IP_IPSEC_REFINFO;
-	cmsg->cmsg_len   = CMSG_LEN(sizeof(unsigned int));
-
-	if(gconfig.debug_network) {
-		l2tp_log(LOG_DEBUG,"sending with saref=%d\n", t->refhim);
-	}
-	refp = (unsigned int *)CMSG_DATA(cmsg);
-	*refp = t->refhim;
-
-	msgh.msg_controllen = cmsg->cmsg_len;
-    }
-    
-    iov.iov_base = buf->start;
-    iov.iov_len  = buf->len;
-
-    /* return packet from whence it came */
-    msgh.msg_name    = &buf->peer;
-    msgh.msg_namelen = sizeof(buf->peer);
-    
-    msgh.msg_iov  = &iov;
-    msgh.msg_iovlen = 1;
-    msgh.msg_flags = 0;
-    
-    /* Receive one packet. */
-    if ((err = sendmsg(server_socket, &msgh, 0)) < 0) {
-	l2tp_log(LOG_ERR, "udp_xmit failed with err=%d:%s\n",
-		 err,strerror(errno));
-    }
-}
-
-int build_fdset (fd_set *readfds)
-{
-	struct tunnel *tun;
-	struct call *call;
-	int max = 0;
-
-	tun = tunnels.head;
-	FD_ZERO (readfds);
-
-	while (tun)
-	{
-		call = tun->call_head;
-		while (call)
-		{
-			if (call->needclose ^ call->closing)
-			{
-				call_close (call);
-				call = tun->call_head;
-				if (!call)
-					break;
-				continue;
-			}
-			if (call->fd > -1)
-			{
-				if (!call->needclose && !call->closing)
-				{
-					if (call->fd > max)
-						max = call->fd;
-					FD_SET (call->fd, readfds);
-				}
-			}
-			call = call->next;
-		}
-		/* Now that call fds have been collected, and checked for
-		 * closing, check if the tunnel needs to be closed too
-		 */
-		if (tun->self->needclose ^ tun->self->closing)
-		{
-			if (gconfig.debug_tunnel)
-				l2tp_log (LOG_DEBUG, "%s: closing down tunnel %d\n",
-						__FUNCTION__, tun->ourtid);
-			call_close (tun->self);
-			/* Reset the while loop
-			 * and check for NULL */
-			tun = tunnels.head;
-			if (!tun)
-				break;
-			continue;
-		}
-		tun = tun->next;
-	}
-	FD_SET (server_socket, readfds);
-	if (server_socket > max)
-		max = server_socket;
-	return max;
-}
-
-void network_thread ()
-{
-    /*
-     * We loop forever waiting on either data from the ppp drivers or from
-     * our network socket.  Control handling is no longer done here.
-     */
-    struct sockaddr_in from, to;
-    unsigned int fromlen, tolen;
-    int tunnel, call;           /* Tunnel and call */
-    int recvsize;               /* Length of data received */
-    struct buffer *buf;         /* Payload buffer */
-    struct call *c, *sc;        /* Call to send this off to */
-    struct tunnel *st;          /* Tunnel */
-    fd_set readfds;             /* Descriptors to watch for reading */
-    int max;                    /* Highest fd */
-    struct timeval tv, *ptv;    /* Timeout for select */
-    struct msghdr msgh;
-    struct iovec iov;
-    char cbuf[256];
-    unsigned int refme, refhim;
-
-    
-    /* This one buffer can be recycled for everything except control packets */
-    buf = new_buf (MAX_RECV_SIZE);
-
-    tunnel = 0;
-    call = 0;
-
-    while( !iexit )
-    {
-        int ret;
-        max = build_fdset (&readfds);
-        ptv = process_schedule(&tv);
-        ret = select (max + 1, &readfds, NULL, NULL, ptv);
-        if (ret <= 0) {
-            continue;
-        }
-	
-	if (FD_ISSET (server_socket, &readfds)) {
-		if( !ioctl(server_socket, FIONREAD, &recvsize) && !recvsize ) break;
-            /*
-             * Okay, now we're ready for reading and processing new data.
-             */
-            recycle_buf (buf);
-
-            /* Reserve space for expanding payload packet headers */
-            buf->start += PAYLOAD_BUF;
-            buf->len -= PAYLOAD_BUF;
-
-	    memset(&from, 0, sizeof(from));
-	    memset(&to,   0, sizeof(to));
-	    
-	    fromlen = sizeof(from);
-	    tolen   = sizeof(to);
-	    
-	    memset(&msgh, 0, sizeof(struct msghdr));
-	    iov.iov_base = buf->start;
-	    iov.iov_len  = buf->len;
-	    msgh.msg_control = cbuf;
-	    msgh.msg_controllen = sizeof(cbuf);
-	    msgh.msg_name = &from;
-	    msgh.msg_namelen = fromlen;
-	    msgh.msg_iov  = &iov;
-	    msgh.msg_iovlen = 1;
-	    msgh.msg_flags = 0;
-	    
-	    /* Receive one packet. */
-	    recvsize = recvmsg(server_socket, &msgh, 0);
-	    
-            if (recvsize < MIN_PAYLOAD_HDR_LEN)
-            {
-                if (recvsize < 0)
-                {
-                    if (errno != EAGAIN)
-                        l2tp_log (LOG_WARNING,
-                             "%s: recvfrom returned error %d (%s)\n",
-                             __FUNCTION__, errno, strerror (errno));
-                }
-                else
-                {
-                    l2tp_log (LOG_WARNING, "%s: received too small a packet\n",
-                         __FUNCTION__);
-                }
-		continue;
-            }
-
-
-	    refme=refhim=0;
-
-	    /* extract IPsec info out */
-	    if(gconfig.ipsecsaref) {
-		    struct cmsghdr *cmsg;
-		    /* Process auxiliary received data in msgh */
-		    for (cmsg = CMSG_FIRSTHDR(&msgh);
-			 cmsg != NULL;
-			 cmsg = CMSG_NXTHDR(&msgh,cmsg)) {
-			    if (cmsg->cmsg_level == IPPROTO_IP
-				&& cmsg->cmsg_type == IP_IPSEC_REFINFO) {
-				    unsigned int *refp;
-				    
-				    refp = (unsigned int *)CMSG_DATA(cmsg);
-				    refme =refp[0];
-				    refhim=refp[1];
-			    }
-		    }
-	    }
-
-	    /*
-	     * some logic could be added here to verify that we only
-	     * get L2TP packets inside of IPsec, or to provide different
-	     * classes of service to packets not inside of IPsec.
-	     */
-	    buf->len = recvsize;
-	    fix_hdr (buf->start);
-	    extract (buf->start, &tunnel, &call);
-
-	    if (gconfig.debug_network)
-	    {
-		l2tp_log(LOG_DEBUG, "%s: recv packet from %s, size = %d, "
-			 "tunnel = %d, call = %d ref=%u refhim=%u\n",
-			 __FUNCTION__, inet_ntoa (from.sin_addr),
-			 recvsize, tunnel, call, refme, refhim);
-	    }
-
-	    if (gconfig.packet_dump)
-	    {
-		do_packet_dump (buf);
-	    }
-	    if (!
-		(c = get_call (tunnel, call, from.sin_addr.s_addr,
-			       from.sin_port, refme, refhim)))
-	    {
-		if ((c =
-		     get_tunnel (tunnel, from.sin_addr.s_addr,
-				 from.sin_port)))
-		{
-		    /*
-		     * It is theoretically possible that we could be sent
-		     * a control message (say a StopCCN) on a call that we
-		     * have already closed or some such nonsense.  To
-		     * prevent this from closing the tunnel, if we get a
-		     * call on a valid tunnel, but not with a valid CID,
-		     * we'll just send a ZLB to ack receiving the packet.
-		     */
-		    if (gconfig.debug_tunnel)
-			l2tp_log (LOG_DEBUG,
-				  "%s: no such call %d on tunnel %d.  Sending special ZLB\n",
-				  __FUNCTION__);
-		    handle_special (buf, c, call);
-
-		    /* get a new buffer */
-		    buf = new_buf (MAX_RECV_SIZE);
-		}
-		else
-		    l2tp_log (LOG_DEBUG,
-			      "%s: unable to find call or tunnel to handle packet.  call = %d, tunnel = %d Dumping.\n",
-			      __FUNCTION__, call, tunnel);
-		
-	    }
-	    else
-	    {
-		buf->peer = from;
-		/* Handle the packet */
-		c->container->chal_us.vector = NULL;
-		if (handle_packet (buf, c->container, c))
-		{
-		    if (gconfig.debug_tunnel)
-			l2tp_log (LOG_DEBUG, "%s: bad packet\n", __FUNCTION__);
-		};
-		if (c->cnu)
-		{
-		    /* Send Zero Byte Packet */
-		    control_zlb (buf, c->container, c);
-		    c->cnu = 0;
-		}
-	    };
-	}
-
-	/*
-	 * finished obvious sources, look for data from PPP connections.
-	 */
-	st = tunnels.head;
-        while (st)
-        {
-            sc = st->call_head;
-            while (sc)
-            {
-					if ((sc->fd >= 0) && FD_ISSET (sc->fd, &readfds)) {
-                    /* Got some payload to send */
-                    int result;
-                    recycle_payload (buf, sc->container->peer);
-/*
-#ifdef DEBUG_FLOW_MORE
-                    l2tp_log (LOG_DEBUG, "%s: rws = %d, pSs = %d, pLr = %d\n",
-                         __FUNCTION__, sc->rws, sc->pSs, sc->pLr);
-#endif
-		    if ((sc->rws>0) && (sc->pSs > sc->pLr + sc->rws) && !sc->rbit) {
-#ifdef DEBUG_FLOW
-						log(LOG_DEBUG, "%s: throttling payload (call = %d, tunnel = %d, Lr = %d, Ss = %d, rws = %d)!\n",__FUNCTION__,
-								 sc->cid, sc->container->tid, sc->pLr, sc->pSs, sc->rws); 
-#endif
-						sc->throttle = -1;
-						We unthrottle in handle_packet if we get a payload packet, 
-						valid or ZLB, but we also schedule a dethrottle in which
-						case the R-bit will be set
-						FIXME: Rate Adaptive timeout? 						
-						tv.tv_sec = 2;
-						tv.tv_usec = 0;
-						sc->dethrottle = schedule(tv, dethrottle, sc); 					
-					} else */
-/*					while ((result=call_read_packet(buf,sc->fd,sc->frame & SYNC_FRAMING))>0) { */
-                    while (!iexit && (result =
-                            call_read_packet (buf, sc->fd, SYNC_FRAMING)) > 0)
-                    {
-                        add_payload_hdr (sc->container, sc, buf);
-                        if (gconfig.packet_dump)
-                        {
-                            do_packet_dump (buf);
-                        }
-
-                        sc->prx = sc->data_rec_seq_num;
-                        if (sc->zlb_xmit)
-                        {
-                            deschedule (sc->zlb_xmit);
-                            sc->zlb_xmit = NULL;
-                        }
-			
-                        sc->tx_bytes += buf->len;
-                        sc->tx_pkts++;
-			
-                        udp_xmit (buf, st);
-                        recycle_payload (buf, sc->container->peer);
-                    }
-                    if (result != 0)
-                    {
-                        l2tp_log (LOG_WARNING,
-                             "%s: tossing read packet, error = %s (%d).  Closing call.\n",
-                             __FUNCTION__, strerror (-result), -result);
-                        strcpy (sc->errormsg, strerror (-result));
-                        sc->needclose = -1;
-                    }
-                }
-                sc = sc->next;
-            }
-            st = st->next;
-        }
-    }
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/osport.h ppp-2.4.4/pppd/plugins/pppol2tp/osport.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/osport.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/osport.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,38 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * OS Portability header file. try to map some
- * "standard" routines into OS-specific routines.
- *
- */
-
-#ifndef _OSPORT_H_
-#define _OSPORT_H_
-
-#if defined(SOLARIS)
-
-# define index(x, y)        strchr(x, y)
-# define bcopy(S1, S2, LEN) ((void)memmove(S2, S1, LEN))
-# define bzero(S1, LEN)     ((void)memset(S1,  0, LEN))
-# define bcmp(S1,S2,LEN)    ((memcmp(S2, S1, LEN)==0)?0:1)
-
-/* pre 2.6 solaris didn't include random(), etc prototypes 
- * <stdlib.h> (as of 2.6) has the correct prototypes.
- */
-
-# if SOLARIS < 260
-#  define random(X)          ((int)rand(X))
-#  define srandom(X)         ((void)srand(X))
-# endif /* SOLARIS < 260 */
-
-#endif /* defined(SOLARIS) */
-
-#endif /* _OSPORT_H_ */
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/scheduler.c ppp-2.4.4/pppd/plugins/pppol2tp/scheduler.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/scheduler.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/scheduler.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,165 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Scheduler code for time based functionality
- *
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include "l2tp.h"
-#include "scheduler.h"
-
-struct schedule_entry *events;
-
-void init_scheduler (void)
-{
-    events = NULL;
-}
-
-struct timeval *process_schedule (struct timeval *ptv)
-{
-    /* Check queue for events which should be
-       executed right now.  Execute them, then
-       see how long we should set the next timer
-     */
-    struct schedule_entry *p = events;
-    struct timeval now;
-    struct timeval then;
-    while (events)
-    {
-        gettimeofday (&now, NULL);
-        p = events;
-        if (TVLESSEQ (p->tv, now))
-        {
-            events = events->next;
-            /* This needs to be executed, as it has expired.
-               It is expected that p->func will free p->data
-               if it is necessary */
-            (*p->func) (p->data);
-            free (p);
-        }
-        else
-            break;
-    }
-    /* When we get here, either there are no more events
-       in the queue, or the remaining events need to happen
-       in the future, so we should schedule another alarm */
-    if (events)
-    {
-        then.tv_sec = events->tv.tv_sec - now.tv_sec;
-        then.tv_usec = events->tv.tv_usec - now.tv_usec;
-        if (then.tv_usec < 0)
-        {
-            then.tv_sec -= 1;
-            then.tv_usec += 1000000;
-        }
-        if ((then.tv_sec <= 0) && (then.tv_usec <= 0))
-        {
-            l2tp_log (LOG_WARNING, "%s: Whoa...  Scheduling for <=0 time???\n",
-                 __FUNCTION__);
-            then.tv_sec = 1;
-            then.tv_usec = 0;
-        }
-        *ptv = then;
-        return ptv;
-    }
-    else
-    {
-        return NULL;
-    }
-}
-
-struct schedule_entry *schedule (struct timeval tv, void (*func) (void *),
-                                 void *data)
-{
-    /* Schedule func to be run at relative time tv with data
-       as arguments.  If it has already expired, run it 
-       immediately.  The queue should be in order of
-       increasing time */
-    struct schedule_entry *p = events, *q = NULL;
-    struct timeval diff;
-    diff = tv;
-    gettimeofday (&tv, NULL);
-    tv.tv_sec += diff.tv_sec;
-    tv.tv_usec += diff.tv_usec;
-    if (tv.tv_usec > 1000000)
-    {
-        tv.tv_sec++;
-        tv.tv_usec -= 1000000;
-    }
-    while (p)
-    {
-        if (TVLESS (tv, p->tv))
-            break;
-        q = p;
-        p = p->next;
-    };
-    if (q)
-    {
-        q->next =
-            (struct schedule_entry *) zalloc (sizeof (struct schedule_entry));
-        q = q->next;
-    }
-    else
-    {
-        q = (struct schedule_entry *) zalloc (sizeof (struct schedule_entry));
-        events = q;
-    }
-    q->tv = tv;
-    q->func = func;
-    q->data = data;
-    q->next = p;
-    return q;
-
-}
-
-inline struct schedule_entry *aschedule (struct timeval tv,
-                                         void (*func) (void *), void *data)
-{
-    /* Schedule func to be run at absolute time tv in the future with data
-       as arguments */
-    struct timeval now;
-    gettimeofday (&now, NULL);
-    tv.tv_usec -= now.tv_usec;
-    if (tv.tv_usec < 0)
-    {
-        tv.tv_usec += 1000000;
-        tv.tv_sec--;
-    }
-    tv.tv_sec -= now.tv_sec;
-    return schedule (tv, func, data);
-}
-
-void deschedule (struct schedule_entry *s)
-{
-    struct schedule_entry *p = events, *q = NULL;
-    if (!s)
-        return;
-    while (p)
-    {
-        if (p == s)
-        {
-            if (q)
-            {
-                q->next = p->next;
-            }
-            else
-            {
-                events = events->next;
-            }
-            free (p);
-            break;
-        }
-        q = p;
-        p = p->next;
-    }
-}
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/scheduler.h ppp-2.4.4/pppd/plugins/pppol2tp/scheduler.h
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/scheduler.h	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/scheduler.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,67 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Scheduler structures and functions
- *
- */
-
-#ifndef _SCHEDULER_H
-#define _SCHEDULER_H
-#include <sys/time.h>
-
-/*
- * The idea is to provide a general scheduler which can schedule
- * events to be run periodically
- */
-
-struct schedule_entry
-{
-    struct timeval tv;          /* Scheduled time to execute */
-    void (*func) (void *);      /* Function to execute */
-    void *data;                 /* Data to be passed to func */
-    struct schedule_entry *next;        /* Next entry in queue */
-};
-
-extern struct schedule_entry *events;
-
-/* Schedule func to be executed with argument data sometime
-   tv in the future. */
-
-struct schedule_entry *schedule (struct timeval tv, void (*func) (void *),
-                                 void *data);
-
-/* Like schedule() but tv represents an absolute time in the future */
-
-struct schedule_entry *aschedule (struct timeval tv, void (*func) (void *),
-                                  void *data);
-
-/* Remove a scheduled event from the queue */
-
-void deschedule (struct schedule_entry *);
-
-/* Initialization function */
-void init_scheduler (void);
-
-/* Scheduled event processor */
-struct timeval *process_schedule(struct timeval *);
-
-/* Compare two timeval functions and see if a <= b */
-
-#define TVLESS(a,b) ((a).tv_sec == (b).tv_sec ? \
-				((a).tv_usec < (b).tv_usec) : \
-				((a).tv_sec < (b).tv_sec))
-#define TVLESSEQ(a,b) ((a).tv_sec == (b).tv_sec ? \
-				((a).tv_usec <= (b).tv_usec) : \
-				((a).tv_sec <= (b).tv_sec))
-#define TVGT(a,b) ((a).tv_sec == (b).tv_sec ? \
-				((a).tv_usec > (b).tv_usec) : \
-				((a).tv_sec > (b).tv_sec))
-#endif
diff -U 3 -dHBbrN -- ppp-2.4.4.old/pppd/plugins/pppol2tp/xl2tpd.c ppp-2.4.4/pppd/plugins/pppol2tp/xl2tpd.c
--- ppp-2.4.4.old/pppd/plugins/pppol2tp/xl2tpd.c	2013-01-17 16:39:52.000000000 +0400
+++ ppp-2.4.4/pppd/plugins/pppol2tp/xl2tpd.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,645 +0,0 @@
-/*
- * Layer Two Tunnelling Protocol Daemon
- * Copyright (C) 1998 Adtran, Inc.
- * Copyright (C) 2002 Jeff McAdams
- *
- *
- * Mark Spencer
- *
- * This software is distributed under the terms
- * of the GPL, which you should have received
- * along with this source.
- *
- * Main Daemon source.
- *
- */
-
-#define _ISOC99_SOURCE
-#define _XOPEN_SOURCE
-#define _BSD_SOURCE
-#define _XOPEN_SOURCE_EXTENDED
-
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <time.h>
-#if (__GLIBC__ < 2)
-# if defined(FREEBSD)
-#  include <sys/signal.h>
-# elif defined(LINUX)
-#  include <bsd/signal.h>
-# elif defined(SOLARIS)
-#  include <signal.h>
-# endif
-#else
-# include <signal.h>
-#endif
-#include <netdb.h>
-#include <string.h>
-#include <strings.h>
-#include <fcntl.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include "l2tp.h"
-#include <sys/ipc.h>
-#include <sys/shm.h>
-
-
-struct tunnel_list tunnels;
-int max_tunnels = DEF_MAX_TUNNELS;
-int rand_source;
-int ppd = 1;                    /* Packet processing delay */
-
-int iexit = 0;
-int isock_fd = -1;
-pid_t control_pid = -1, manager_pid = -1;
-key_t key;
-
-typedef struct {
-	int ifd;
-	uint32_t ipv4_addr;
-	uint16_t port;
-	uint32_t ourtid;
-	uint32_t ourcid;
-	uint32_t tid;
-	uint32_t cid;
-} SHT, *PSHT;
-
-int shmid;
-PSHT segptr = NULL;
-
-extern int _stat_get();
-extern void _stat_write_status( int a_nStat );
-extern void _stat_write_result( int a_nStat );
-extern void _stat_write_chain( int a_nStat );
-
-void init_tunnel_list (struct tunnel_list *t) {
-    t->head = NULL;
-    t->count = 0;
-    t->calls = 0;
-}
-
-void stop_pppd (int istat) {
-     if( istat != -1 ) {
-    	 _stat_write_status(istat);
- 		 _stat_write_result(istat);
- 		 _stat_write_chain(istat);
- 		 l2tp_log (LOG_WARNING, "%s: exit(%d).\n", __FUNCTION__, istat);
-     }
-	
-     if( !iexit ) {
-  		 iexit = 1;
-		 if( istat != -1 && control_pid != -1 ) {
-			 kill(control_pid, SIGHUP);
-    }
-
-		 segptr->ifd = -2; /* notify mark */
-    }
-}
-    
-void start_pppd (struct call *c) {
-    segptr->ifd = server_socket;
-	 segptr->ipv4_addr = c->container->peer.sin_addr.s_addr;
-	 segptr->port = c->container->peer.sin_port;
-	 segptr->ourtid = c->container->ourtid;
-	 segptr->ourcid = c->ourcid;
-	 segptr->tid = c->container->tid;
-	 segptr->cid = c->cid;
-}
-
-void destroy_tunnel (struct tunnel *t) {
-    /*
-     * Immediately destroy a tunnel (and all its calls)
-     * and free its resources.  This may be called
-     * by the tunnel itself,so it needs to be
-     * "suicide safe"
-     */
-     
-    struct call *c, *me;
-    struct tunnel *p;
-    struct timeval tv;
-    if (!t)
-        return;
-
-    /*
-     * Save ourselves until the very
-     * end, since we might be calling this ourselves.
-     * We must divorce ourself from the tunnel
-     * structure, however, to avoid recursion
-     * because of the logic of the destroy_call
-     */
-    me = t->self;
-
-    /*
-     * Destroy all the member calls
-     */
-    c = t->call_head;
-    while (c)
-    {
-        destroy_call (c);
-        c = c->next;
-    };
-    /*
-     * Remove ourselves from the list of tunnels
-     */
-
-    if (tunnels.head == t)
-    {
-        tunnels.head = t->next;
-        tunnels.count--;
-    }
-    else
-    {
-        p = tunnels.head;
-        if (p)
-        {
-            while (p->next && (p->next != t))
-                p = p->next;
-            if (p->next)
-            {
-                p->next = t->next;
-                tunnels.count--;
-            }
-            else
-            {
-                l2tp_log (LOG_WARNING,
-                     "%s: unable to locate tunnel in tunnel list\n",
-                     __FUNCTION__);
-            }
-        }
-        else
-        {
-            l2tp_log (LOG_WARNING, "%s: tunnel list is empty!\n", __FUNCTION__);
-        }
-    }
-    if (t->lac) {
-        t->lac->t = NULL;
-    }
-    /* XXX L2TP/IPSec: remove relevant SAs here?  NTB 20011010
-     * XXX But what if another tunnel is using same SA?
-     */
-    if (t->chal_us.challenge)
-        free (t->chal_us.challenge);
-    if (t->chal_them.challenge)
-        free (t->chal_them.challenge);
-    /* we need no free(t->chal_us.vector) here because we zalloc() and free()
-       the memory pointed to by t->chal_us.vector at some other place */
-    if (t->chal_them.vector)
-        free (t->chal_them.vector);
-    free (t);
-    free (me);
-}
-
-struct tunnel *l2tp_call (char *host, int port, struct lac *lac)
-{
-    /*
-     * Establish a tunnel from us to host
-     * on port port
-     */
-    struct call *tmp = NULL;
-    struct hostent *hp;
-    unsigned int addr;
-    port = htons (port);
-    hp = gethostbyname (host);
-    if (!hp)
-    {
-        l2tp_log (LOG_WARNING, "Host name lookup failed for %s.\n",
-             host);
-
-        // zw : if server doesn't lookup -- exit
-        stop_pppd(3);
-        return NULL;
-    }
-    bcopy (hp->h_addr, &addr, hp->h_length);
-    /* Force creation of a new tunnel
-       and set it's tid to 0 to cause
-       negotiation to occur */
-    /*
-     * to do IPsec properly here, we need to set a socket policy,
-     * and/or communicate with pluto.
-     */
-    tmp = get_call (0, 0, addr, port, IPSEC_SAREF_NULL, IPSEC_SAREF_NULL);
-    if (!tmp)
-    {
-        l2tp_log (LOG_WARNING, "%s: Unable to create tunnel to %s.\n", __FUNCTION__,
-             host);
-        return NULL;
-    }
-    tmp->container->tid = 0;
-    tmp->container->lac = lac;
-    tmp->lac = lac;
-    if (lac)
-        lac->t = tmp->container;
-    /*
-     * Since our state is 0, we will establish a tunnel now
-     */
-    l2tp_log (LOG_NOTICE, "Connecting to host %s, port %d\n", host,
-         ntohs (port));
-    control_finish (tmp->container, tmp);
-    return tmp->container;
-}
-
-void magic_lac_tunnel (void *data)
-{
-    struct lac *lac;
-    lac = (struct lac *) data;
-    if (!lac)
-    {
-        l2tp_log (LOG_WARNING, "%s: magic_lac_tunnel: called on NULL lac!\n",
-             __FUNCTION__);
-        return;
-    }
-    if (lac->lns)
-    {
-        /* FIXME: I should try different LNS's if I get failures */
-        l2tp_call (lac->lns->hostname, lac->lns->port, lac);
-        return;
-    }
-    else
-    {
-        l2tp_log (LOG_WARNING, "%s: Unable to find hostname to dial for '%s'\n",
-             __FUNCTION__, lac->entname);
-        return;
-    }
-}
-
-struct call *lac_call (int tid, struct lac *lac)
-{
-    struct tunnel *t = tunnels.head;
-    struct call *tmp;
-    
-    while (t)
-    {
-        if (t->ourtid == tid)
-        {
-            tmp = new_call (t);
-            if (!tmp)
-            {
-                l2tp_log (LOG_WARNING, "%s: unable to create new call\n",
-                     __FUNCTION__);
-                return NULL;
-            }
-            tmp->next = t->call_head;
-            t->call_head = tmp;
-            t->count++;
-            tmp->cid = 0;
-            tmp->lac = lac;
-            if (lac)
-                lac->c = tmp;
-            l2tp_log (LOG_NOTICE, "Calling on tunnel %d\n", tid);
-            control_finish (t, tmp);
-            return tmp;
-        }
-        t = t->next;
-    };
-    l2tp_log (LOG_DEBUG, "%s: No such tunnel %d to generate call.\n", __FUNCTION__,
-         tid);
-    return NULL;
-}
-
-void magic_lac_dial (void *data)
-{
-    struct lac *lac;
-    lac = (struct lac *) data;
-    if (!lac->active)
-    {
-        l2tp_log (LOG_DEBUG, "%s: LAC %s not active", __FUNCTION__, lac->entname);
-        return;
-    }
-    lac->rsched = NULL;
-    if (!lac)
-    {
-        l2tp_log (LOG_WARNING, "%s : called on NULL lac!\n", __FUNCTION__);
-        return;
-    }
-    if (!lac->t)
-    {
-#ifdef DEGUG_MAGIC
-        l2tp_log (LOG_DEBUG, "%s : tunnel not up!  Connecting!\n", __FUNCTION__);
-#endif
-        magic_lac_tunnel (lac);
-        return;
-    }
-    lac_call (lac->t->ourtid, lac);
-}
-
-void lac_hangup (int cid)
-{
-    struct tunnel *t = tunnels.head;
-    struct call *tmp;
-    while (t)
-    {
-        tmp = t->call_head;
-        while (tmp)
-        {
-            if (tmp->ourcid == cid)
-            {
-                l2tp_log (LOG_INFO,
-                     "%s :Hanging up call %d, Local: %d, Remote: %d\n",
-                     __FUNCTION__, tmp->serno, tmp->ourcid, tmp->cid);
-                strcpy (tmp->errormsg, "Goodbye!");
-		stop_pppd(0);
-                return;
-            }
-            tmp = tmp->next;
-        }
-        t = t->next;
-    };
-    l2tp_log (LOG_DEBUG, "%s : No such call %d to hang up.\n", __FUNCTION__, cid);
-    return;
-}
-
-void lac_disconnect (int tid)
-{
-    struct tunnel *t = tunnels.head;
-    while (t)
-    {
-        if (t->ourtid == tid )
-        {
-            l2tp_log (LOG_INFO,
-                 "Disconnecting from %s, Local: %d, Remote: %d\n",
-                 IPADDY (t->peer.sin_addr), t->ourtid, t->tid);
-            t->self->needclose = -1;
-            strcpy (t->self->errormsg, "Goodbye!");
-            call_close (t->self);
-            return;
-        }
-        t = t->next;
-    };
-    //l2tp_log (LOG_DEBUG, "No such tunnel %d to hang up.\n", tid);
-    return;
-}
-
-
-struct tunnel *new_tunnel ()
-{
-    struct tunnel *tmp = zalloc (sizeof (struct tunnel));
-    unsigned char entropy_buf[2] = "\0";
-    if (!tmp)
-        return NULL;
-    tmp->control_seq_num = 0;
-    tmp->control_rec_seq_num = 0;
-    tmp->cLr = 0;
-    tmp->call_head = NULL;
-    tmp->next = NULL;
-    tmp->debug = -1;
-    tmp->tid = -1;
-    tmp->hello = NULL;
-#ifndef TESTING
-/*      while(get_call((tmp->ourtid = rand() & 0xFFFF),0,0,0)); */
-/*        tmp->ourtid = rand () & 0xFFFF; */
-        /* get_entropy((char *)&tmp->ourtid, 2); */
-        get_entropy(entropy_buf, 2);
-        {
-            unsigned short *temp;
-            temp = (unsigned short *)entropy_buf;
-            tmp->ourtid = *temp & 0xFFFF;
-#ifdef DEBUG_ENTROPY
-            l2tp_log(LOG_DEBUG, "ourtid = %u, entropy_buf = %hx\n", tmp->ourtid, *temp);
-#endif
-        }
-
-#else
-    tmp->ourtid = 0x6227;
-#endif
-    tmp->nego = 0;
-    tmp->count = 0;
-    tmp->state = 0;             /* Nothing */
-    tmp->peer.sin_family = AF_INET;
-    tmp->peer.sin_port = 0;
-    bzero (&(tmp->peer.sin_addr), sizeof (tmp->peer.sin_addr));
-#ifdef SANITY
-    tmp->sanity = -1;
-#endif
-    tmp->qtid = -1;
-    tmp->ourfc = ASYNC_FRAMING | SYNC_FRAMING;
-    tmp->ourbc = 0;
-    tmp->ourtb = (((_u64) rand ()) << 32) | ((_u64) rand ());
-    tmp->fc = -1;               /* These really need to be specified by the peer */
-    tmp->bc = -1;               /* And we want to know if they forgot */
-    tmp->hostname[0] = 0;
-    tmp->vendor[0] = 0;
-    tmp->secret[0] = 0;
-    if (!(tmp->self = new_call (tmp)))
-    {
-        free (tmp);
-        return NULL;
-    };
-    tmp->ourrws = DEFAULT_RWS_SIZE;
-    tmp->self->ourfbit = FBIT;
-    tmp->lac = NULL;
-    tmp->chal_us.state = 0;
-    tmp->chal_us.secret[0] = 0;
-    memset (tmp->chal_us.reply, 0, MD_SIG_SIZE);
-    tmp->chal_us.challenge = NULL;
-    tmp->chal_us.chal_len = 0;
-    tmp->chal_them.state = 0;
-    tmp->chal_them.secret[0] = 0;
-    memset (tmp->chal_them.reply, 0, MD_SIG_SIZE);
-    tmp->chal_them.challenge = NULL;
-    tmp->chal_them.chal_len = 0;
-    tmp->chal_them.vector = (unsigned char *) zalloc (VECTOR_SIZE);
-    tmp->chal_us.vector = NULL;
-    tmp->hbit = 0;
-    return tmp;
-}
-
-int manager_active() {
-	int iwaitstatus, iret;
-	
-	if( manager_pid != -1 ) {
-		if( (iret = waitpid(manager_pid, &iwaitstatus, WNOHANG)) == 0 ) return 1;
-		else if( iret != -1 && !WIFEXITED(iwaitstatus) && !WIFSIGNALED(iwaitstatus) ) return 1;
-		
-		manager_pid = -1;
-	}
-				
-	return 0;
-}
-
-
-void l2tp_wait_socket() {
-	while( 1 ) {
-		if( !manager_active() ) break;
-		if( segptr->ifd > 0 || segptr->ifd == -2 ) break;
-		usleep(50000);
-	} 
-}
-
-int l2tp_get_socket() {
-	int flags;
-   struct sockaddr_pppol2tp sax;
-   
-   if( isock_fd != -1 ) return isock_fd;
-   if( segptr->ifd < 0 ) return -1;
-   
-   isock_fd = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OL2TP);
-   if( isock_fd < 0 ) {
-		l2tp_log (LOG_WARNING, "%s: Unable to allocate PPPoL2TP socket.\n",
-			__FUNCTION__);
-		
-		isock_fd = -1;
-		return -2;
-   }
-   
-   flags = fcntl(isock_fd, F_GETFL);
-   if( flags == -1 || fcntl(isock_fd, F_SETFL, flags | O_NONBLOCK) == -1 ) {
-    	l2tp_log (LOG_WARNING, "%s: Unable to set PPPoL2TP socket nonblock.\n",
-    			__FUNCTION__);
-		close(isock_fd);
-		isock_fd = -1;
-    	return -3;
-   }
-    
-   sax.sa_family = AF_PPPOX;
-   sax.sa_protocol = PX_PROTO_OL2TP;
-   sax.pppol2tp.pid = 0;
-   sax.pppol2tp.fd = segptr->ifd;
-   sax.pppol2tp.addr.sin_addr.s_addr = segptr->ipv4_addr;
-   sax.pppol2tp.addr.sin_port = segptr->port;
-   sax.pppol2tp.addr.sin_family = AF_INET;
-   sax.pppol2tp.s_tunnel  = segptr->ourtid;
-   sax.pppol2tp.s_session = segptr->ourcid;
-   sax.pppol2tp.d_tunnel  = segptr->tid;
-   sax.pppol2tp.d_session = segptr->cid;
-   if( connect(isock_fd, (struct sockaddr *)&sax, sizeof(sax)) < 0 ) {
-    	l2tp_log (LOG_WARNING, "%s: Unable to connect PPPoL2TP socket.\n",
-    			__FUNCTION__);
-
-		close(isock_fd);
-		isock_fd = -1;
-		return -4;
-   }
-   
-   //close_network();
-
-	return isock_fd;
-}
-
-void on_term(int isig) {
-	stop_pppd(-1);
-}
-
-int l2tp_init(char *lns) {
-    struct lac *lac;
-    struct in_addr listenaddr;
-    struct tunnel *t;
-    pid_t fpid;
-    int itry;
-    
-    key = ftok("/dev/shm/l2tp", 'S');
-    srand( time(NULL) );
-    rand_source = 0;
-
-    init_config(lns);
-    init_tunnel_list(&tunnels);
-
-    if( init_network () ) return -1;
-    
-    switch( (fpid = fork()) ) {
-    case -1: 
-   	 close_network();
-		return -1;
-    case 0: control_pid = getppid(); break;
-    default: 
-   	 manager_pid = fpid; 
-		 
-		 if( (shmid = shmget(key, sizeof(SHT), IPC_CREAT|IPC_EXCL|0666)) == -1 ) {
-  			if( (shmid = shmget(key, sizeof(SHT), 0)) == -1 ) {
-  				close_network(); return -1;
-	  			}
-		 }
-		 
-		 if( (segptr = (PSHT)shmat(shmid, 0, 0)) == (int*)-1 ) {
-			segptr = NULL;
-     		shmctl(shmid, IPC_RMID, 0);
-     		close_network();
-		return -1;
-  		 }
-  		 
-  		 segptr->ifd = -1; /* wait for manager */
-   	 return 0;
-    }
-    
-    /* manager part */
-    
-    itry = 0;
-    while( ++itry < 20 ) { /* average 1 sec */
-   	if( (shmid = shmget(key, sizeof(SHT), 0)) != -1 ) {
-			segptr = (PSHT)shmat(shmid, 0, 0);
-			break;
-		}
-		usleep(50000);
-  	 }
-  	 
-  	 if( segptr == (PSHT)-1 ) {
-  		close_network();
-  		exit(-112);
-  	 }
-
-    init_scheduler ();
-    
-    l2tp_log (LOG_INFO, "l2tp version " SERVER_VERSION " started on %s PID:%d\n",
-         hostname, getpid ());
-
-    listenaddr.s_addr = gconfig.listenaddr;
-
-    lac = laclist;
-    if (lac)
-    {
-#ifdef DEBUG_MAGIC
-            l2tp_log (LOG_DEBUG, "%s: Autodialing '%s'\n", __FUNCTION__,
-                 lac->entname[0] ? lac->entname : "(unnamed)");
-#endif
-            lac->active = -1;
-            magic_lac_dial (lac);
-    }
-    
-    signal(SIGTERM, on_term);
-    signal(SIGINT, on_term);
-    signal(SIGHUP, on_term);
-
-    network_thread();
-    
-    if( (t = tunnels.head) ) 
-   	lac_disconnect(t->ourtid);
-    
-    shmdt(segptr);
-    close_network();
-    
-    exit(0);
-    return 0;
-}
-
-void l2tp_exit() {
-	 int itry;
-    
-    if( isock_fd != -1 ) {
-        close(isock_fd);
-        isock_fd = -1;
-    }
-    
-    close_network();
-    
-	 if( manager_active() ) {
-		 kill(manager_pid, SIGHUP);
-		 
-		 itry = 0;
-		 while( ++itry < 20 ) { /* average 1 sec */
-			 if( !manager_active() ) break;
-			 usleep(50000);
-		 }
-		 
-		 if( manager_active() ) kill(manager_pid, SIGKILL);
-	 }
-    
-    if( segptr ) {
-		shmdt(segptr);
-		shmctl(shmid, IPC_RMID, 0);
-		segptr = NULL;
-	}
-}
